---
title: "3.3 Create Heatmaps"
---

# Import packages
```{r}
library(tidyverse)
library(stringi)
library(scales)
library(ggplot2)
library(viridis)
library(patchwork)
library(grDevices)
library(RColorBrewer)
sessionInfo()
```

# Define rootpaths (please add additional rootpaths that fit your PC, then hashtag out mine, rather than deleting them)
```{r}
#ghp = "C:/Users/sgmmahon/Documents/GitHub/timely/"
ghp = "C:/Users/micha/OneDrive/Documents/GitHub/timely/"
dp  = "//rfs01/rdm01/Timely/data/"
lp  = "_lookups/"
mtp = "_matrices/"
olp = "_outliers/"
cnp = "census/"
csp = "casen/"
erp = "electoral-roll/"
msp = "msdf/"
twp = "twitter/"
vfp = "vector-files/"
ptp = "manuscript/plots/"
scp = "1_scatter_plots/"
bcp = "2_bar_charts/"
hmp = "3_heatmaps/"
crp = "4_correlation_plots/"
hbp = "5_hybrid_plots/"
tbp = "6_tables/"
mcp = "7_misc/"
aap = "8_additional_analysis/"
mfp = "1_migration_flow/"
omp = "2_out_migration/"
imp = "3_in_migration/"
nmp = "4_net_migration/"
pfp = "5_proportion_of_migration_flow/"
smp = "_supplementary_materials/"
```



# Import and format data
```{r}
# Import long-format migration matrices
provincia = read.table(paste0(dp,mtp,"provincia_matrices_long_format.csv"), header = T, sep = ",", na = "") %>% setNames(c("Origin  ~  Destination",names(.)[2:ncol(.)]))
region    = read.table(paste0(dp,mtp,"region_matrices_long_format.csv")   , header = T, sep = ",", na = "") %>% setNames(c("Origin  ~  Destination",names(.)[2:ncol(.)]))

# Import lookup tables
lkp    = read.csv(paste0(dp,lp,"chile_provincia_region_lookup_table.csv"))

# Create origin and destination versions of lookup table for joining
lkp_og = lkp %>% setNames(c("Origin"     ,"ogr"))
lkp_dn = lkp %>% setNames(c("Destination","dnr"))

# Assign origin and destination regions to provincia data
provincia = provincia %>% full_join(lkp_og) %>% full_join(lkp_dn) %>% arrange(ogr,Origin,dnr,Destination) %>% .[c(1:3,((ncol(.)-1):(ncol(.))),(4:(ncol(.)-2)))]
```
```{r,message=FALSE}
# IMPORT PACKAGES
#library(hhmR)



# CREATE TOY DATA OF INTERNAL MIGRATION BETWEEN COUNTIES (LOWER LEVEL) AND REGIONS (UPPER LEVEL)

# Define names of fake counties
fake_counties = c("Greenridge","Windermoor","Bramblewood","Silverlake","Thornbury","Maplewood",
                  "Hawthorne","Pinehurst","Riverton","Meadowbrook","Fairhaven","Oakdale","Stonebridge",
                  "Brookfield","Ashford","Glenville","Sunnyvale","Westfield")

# Create region county lookup tables
rc_lkp = data.frame(region = c(rep("North",3),rep("Midlands",5),rep("South West",4),rep("South East",6)), county = fake_counties)
og_lkp = rc_lkp %>% setNames(c("Origin Region"     ,"Origin County"     ))
dn_lkp = rc_lkp %>% setNames(c("Destination Region","Destination County"))

# Create dataframe of fake migration data
set.seed(1234)
od_df = expand.grid(fake_counties,fake_counties) %>% setNames(paste(c("Origin","Destination"),"County",sep=" ")) %>% full_join(og_lkp) %>% full_join(dn_lkp) %>% 
        mutate(Migration = (1/rgamma(18*18, shape = 17, rate = 0.5)) %>% {. * 1000} %>% round())
od_df[od_df$`Origin County` == od_df$`Destination County`,"Migration"] = od_df[od_df$`Origin County` == od_df$`Destination County`,"Migration"] * 10



# RUN FUNCTION

# Intial heatmap
hierarchical_heatmap = hhm(df = od_df, 
                           ylower = "Origin County", 
                           xlower = "Destination County", 
                           yupper = "Origin Region", 
                           xupper = "Destination Region", 
                           values = "Migration", 
                           yttl_width = 0.22, 
                           xttl_height = 0.4)

# View result
hierarchical_heatmap

# Remove diagonal from heatmap (i.e. hide static populations)
removed_diag         = hhm(df = od_df, 
                           ylower = "Origin County", 
                           xlower = "Destination County", 
                           yupper = "Origin Region", 
                           xupper = "Destination Region", 
                           values = "Migration", 
                           yttl_width = 0.22, 
                           xttl_height = 0.4, 
                           rm_diag = T)

# Vuew result
removed_diag

# Nomalise the legend
normalised_lgd       = hhm(df = od_df, 
                           ylower = "Origin County", 
                           xlower = "Destination County", 
                           yupper = "Origin Region", 
                           xupper = "Destination Region", 
                           values = "Migration", 
                           yttl_width = 0.22, 
                           xttl_height = 0.4, 
                           rm_diag = T,
                           norm_lgd = T)

# View result
normalised_lgd

# Manually define colour scheme for heatmap (uses viridis colour scheme)
viridis_12 = c("#440154FF","#482173FF","#433E85FF","#38598CFF","#2D708EFF","#25858EFF","#1E9B8AFF","#2BB07FFF","#51C56AFF","#85D54AFF","#C2DF23FF","#FDE725FF")

# Assign continuous colour scheme
cont_clrs            = hhm(df = od_df, 
                           ylower = "Origin County", 
                           xlower = "Destination County", 
                           yupper = "Origin Region", 
                           xupper = "Destination Region", 
                           values = "Migration", 
                           yttl_width = 0.22, 
                           xttl_height = 0.4, 
                           rm_diag = T,
                           norm_lgd = T,
                           cclrs = viridis_12)

# View result
cont_clrs

# Break legends into a specified number of bins (of equal intervals between 0 and the maximum value in `values`)
bins_15              = hhm(df = od_df, 
                           ylower = "Origin County", 
                           xlower = "Destination County", 
                           yupper = "Origin Region", 
                           xupper = "Destination Region", 
                           values = "Migration", 
                           yttl_width = 0.22, 
                           xttl_height = 0.4, 
                           rm_diag = T,
                           bins = 15)

# View result
bins_15

# Create breaks to view data using a categoric scale.
# In this instance, the `hhmR` function `log_seq` has been used to create a vector of logarithmicly increasing values between 1 and 
# the maximum value in the dataset not on the diagonal.
cbrks = log_seq(od_df %>% filter(`Origin County` != `Destination County`) %>% .$Migration %>% max(), 12, rmv_extremes = T)

# Manually assign legend categories
legend_cats          = hhm(df = od_df, 
                           ylower = "Origin County", 
                           xlower = "Destination County", 
                           yupper = "Origin Region", 
                           xupper = "Destination Region", 
                           values = "Migration", 
                           yttl_width = 0.22, 
                           xttl_height = 0.4, 
                           rm_diag = T,
                           cbrks = cbrks)

# View result
legend_cats

# Manually assign colours to legend categories
cat_clrs             = hhm(df = od_df, 
                           ylower = "Origin County", 
                           xlower = "Destination County", 
                           yupper = "Origin Region", 
                           xupper = "Destination Region", 
                           values = "Migration", 
                           yttl_width = 0.22, 
                           xttl_height = 0.4, 
                           rm_diag = T,
                           cbrks = cbrks,
                           cclrs = viridis_12)

# View result
cat_clrs
```



```{r}
#' @title log_seq
#'
#' @description Creates a vector of logarithmicly increasing values between 0 and a specified value `n`.
#' If `n` is specified as 1, the vector will be scaled to between 0 and 1.
#'
#' @param n The maximum value that the values in the sequence are scaled to.
#' @param ln How many colour gradients to use in the legend (defaults to 15).
#' @param round_values Option to round values to whole numbers (defaults to `TRUE`).
#' @param rmv_extremes Option to remove zero and the maximum value (i.e. `n`) from the beginning 
#' and the end of the returned vector (defaults to `FALSE`). Note that this will mean the length
#' of the returned vector will be `n` - 2.
#'
#' @return A vector containing of logarithmicly increasing values between 1 and a specified value `n`.
#' 
#' @examples
#' # Create sequence of length 20, scaled between 1 and 500
#' log_seq(500,20)
#' 
#' # Create sequence of length 15, scaled between 0 and 1
#' log_seq(1,12)
#' 
#' @export
#' @importFrom dplyr "%>%"
log_seq = function(n,ln=15,round_values=T,rmv_extremes=F) {

  # Create a sequence from 1 to n. 
  # If `n` is specified as 1, the vector will be scaled to between 0 and 1.
  if (n == 1) {
    seq = seq(1, 1000, length.out = ln)
    round_values = F
  } else {
    seq = seq(1, n, length.out = ln-1)
  }
  
  # Apply the logarithm to the sequence
  log_seq = log(seq)
  
  # Scale the sequence to the range [0, 1]
  min_val = min(log_seq)
  max_val = max(log_seq)
  one_seq = ((log_seq - min_val) / (max_val - min_val))
  
  # Reverse pattern of scale so breaks are focussed on lower rather than upper end of scale
  one_seq_rev = one_seq %>% {. - max(.)} %>% {. * -1} %>% rev()
  
  # Scale sequence to n
  if (round_values) { 
    scaled_one_seq = one_seq_rev %>% {. * n} %>% round() %>% .[2:length(.)] %>% c(0,1,.)
  } else if (n == 1) {
    scaled_one_seq = one_seq_rev
  } else {
    scaled_one_seq = one_seq_rev %>% {. * n} %>% .[2:length(.)] %>% c(0,.Machine$double.xmin,.)
  }
  
  # Option to remove zero and the maximum value (i.e. `n`) from the beginning and the end of the vector
  if (rmv_extremes) {
    scaled_one_seq = scaled_one_seq %>% .[2:(length(.)-1)]
  }
  
  # Return scaled sequence
  return(scaled_one_seq)
}
```

```{r}
#' @title plt_ttl
#'
#' @description Creates plot containing the name of a given upper group. Used in combination with the 
#' patchwork package to plot the names of the upper groups within the hhm function.
#' 
#' @param ttl The name of the upper group.
#' @param axs The axis on which the name will appear. If `x`, the text will be written at the 
#' top-centre of the plot. If `y`, the text will be written at the middle-right of the plot.
#'
#' @return A ggplot object containing the title of a given upper group, for use in the hhm function.
#' 
#' @examples
#' plt_ttl("Group 1",axs="y")
#' plt_ttl("Group 2")
#' 
#' @export
plt_ttl = function(ttl,axs="x") {
  
  # If plotting on x-axis
  if (axs == "x") {
    
    # Place at top of plot and rotate 90 degrees
    p = ggplot(data.frame(x = 0:1, y = 0:1), aes(x = x, y = y)) + 
      geom_point(col = "white") + 
      geom_text(x = 0.495, y = 1, angle = 90, label = ttl, size = 4, hjust = 1) + 
      coord_cartesian(xlim = c(0,1), ylim = c(0,1)) +
      theme_void() +
      theme(plot.margin = unit(rep(0,4), "cm"))
    
  } else if (axs == "y") { # If plotting on y-axis
    
    # Place at left of plot
    p = ggplot(data.frame(x = 0:1, y = 0:1), aes(x = x, y = y)) + 
      geom_point(col = "white") + 
      geom_text(x = 1, y = 0.51, angle =  0, label = ttl, size = 4, hjust = 1) + 
      coord_cartesian(xlim = c(0,1), ylim = c(0,1)) +
      theme_void() +
      theme(plot.margin = unit(rep(0,4), "cm"))

  }
  
  # Return region name plot
  return(p)
}
```



```{r}
#' @title cg
#'
#' @description Creates colour gradient between two hexcodes.
#' 
#' @param colour1 The first hexcode colour.
#' @param colour1 The second hexcode colour.
#' @param n The length of the vector returned by the function.
#'
#' @return A vector of hexcodes of length n, containing a colour gradient between colour =1 and colour2.
#' 
#' @examples
#' cg("white","black",20)
#' 
#' @export
#' @importFrom grDevices
cg = function(colour1, colour2, n = 15) {
  
  # Create a color palette function
  colour_func <- grDevices::colorRampPalette(c(colour1, colour2))
  
  # Generate the color gradient
  colour_gradient <- colour_func(n)
  
  # Return colour gradient
  return(colour_gradient)
}
```


```{r}
#' @title decimalplaces
#'
#' @description Tests the number of non-zero decimal places within a number.
#' 
#' @param x The number for the number of decimal places is to be measured.
#'
#' @return A single number, indicating the number of non-zero decimal places in `x`.
#' 
#' @examples
#' decimalplaces(23.43234525)
#' decimalplaces(334.3410000000000000)
#' decimalplaces(2.000)
#' 
#' @export
decimalplaces <- function(x) {
    if (abs(x - round(x)) > .Machine$double.eps^0.5) {
        nchar(strsplit(sub('0+$', '', as.character(x)), ".", fixed = TRUE)[[1]][[2]])
    } else {
        return(0)
    }
}
```



```{r, fig.width=20}
#' @title hhm
#'
#' @description Creates a labelled heatmap from heirarchical data. This function is
#' useful if you wish to create a heatmap where the categories shown on both the x
#' and y axis can be grouped in some way. This heatmap will order the categories by
#' their assigned group and present both the categories and group labels along the 
#' axes. An example might be series of smaller geographies (lower categories) which 
#' aggregate into larger geographical regions (upper groups).
#' 
#' @param df A data.frame with containing values with which to populate the heatmap. 
#' The data.frame must include columns specifying the lower categories (ylower, 
#' xlower) and upper groups (yupper, xupper) that each value corresponds to. These 
#' categories and groups will be used to arrange and label the rows and columns of 
#' the heatmap. Note that the groups will by default be arranged alphabetically
#' (top to bottom / left to right). The ordering of the groups can be manually 
#' specified by converting yupper and/or xupper to factors. In this case, the 
#' groups will be ordered based on the ordering of the factor levels.
#' @param ylower A column in `df` containing the categories that will be presented 
#' as rows along the y-axis of the heatmap.
#' @param xlower A column in `df` containing the categories that will be presented 
#' as columns along the x-axis of the heatmap.
#' @param yupper A column in `df` containing the groupings that will be used to 
#' arrange the heatmap rows.
#' @param xupper A column in `df` containing the groupings that will be used to 
#' arrange the heatmap columns.
#' @param values A column in `df` containing the values used to populate the 
#' heatmap.
#' @param rm_diag Do not show values for categories along the x and y axes that 
#' are identical (defaults to `FALSE`). This is particularly useful for 
#' origin-destination heatmaps, where the user may want to hide the diagonal 
#' values.
#' @param lgttl Option to manually define legend title.
#' @param bins Option to break the data into a specified number of groups 
#' (defaults to `NULL`). The thresholds between these groups will be equally 
#' spaced between the minimum and maximum values observed in `values`.
#' @param cbrks Vector of custom breaks, if users wish to use a discrete legend 
#' colour scheme (defaults to `NULL`). For example, a supplied vector of `c(5,10,
#' 20)` would break he values up into 5 ordered groups of ranges 0, 0-5, 5-10,
#' 10-20 and 20+.
#' @param cclrs Vector of hexcodes, which to create a custom legend colour scheme 
#' (defaults to `NULL`). If `cbrks` is supplied, `cclrs` must have a length 
#' two longer than `cbrks`. If `bins` is supplied, `cclrs` must have a length 
#' equal to the values provided to `bins`.
#' @param norm_lgd Normalised to between 0 and 1 in legend (defaults to `FALSE`).
#' Allows for consistency when comparing heatmaps across different datasets. At 
#' present, this only works all heatmap values are positive.
#' @param lgdps If using custom breaks, define the number of decimal points to 
#' round the legend scale to (defaults to 0). If `norm_lgd` is `TRUE`, it will 
#' default to 3.
#' @param xttl_height The space allocated to the group titles on the x-axis as a
#' proportion of the heatmap's height (defaults to 0.15).
#' @param yttl_width The space allocated to the group titles on the y-axis as a
#' proportion of the heatmap's width (defaults to 0.15).
#'
#' @return A ggplot object containing the final heatmap.
#' 
#' @examples
#' # CREATE TOY DATA OF INTERNAL MIGRATION BETWEEN COUNTIES (LOWER LEVEL) AND REGIONS (UPPER LEVEL)
#' 
#' # Define names of fake counties
#' fake_counties = c("Greenridge","Windermoor","Bramblewood","Silverlake","Thornbury","Maplewood",
#'                   "Hawthorne","Pinehurst","Riverton","Meadowbrook","Fairhaven","Oakdale","Stonebridge",
#'                   "Brookfield","Ashford","Glenville","Sunnyvale","Westfield")
#' 
#' # Create region county lookup tables
#' rc_lkp = data.frame(region = c(rep("North",3),rep("Midlands",5),rep("South West",4),rep("South East",6)), county = fake_counties)
#' og_lkp = rc_lkp %>% setNames(c("Origin Region"     ,"Origin County"     ))
#' dn_lkp = rc_lkp %>% setNames(c("Destination Region","Destination County"))
#' 
#' # Create dataframe of fake migration data
#' set.seed(1234)
#' od_df = expand.grid(fake_counties,fake_counties) %>% setNames(paste(c("Origin","Destination"),"County",sep=" ")) %>% full_join(og_lkp) %>% full_join(dn_lkp) %>% 
#'         mutate(Migration = (1/rgamma(18*18, shape = 17, rate = 0.5)) %>% {. * 1000} %>% round())
#' od_df[od_df$`Origin County` == od_df$`Destination County`,"Migration"] = od_df[od_df$`Origin County` == od_df$`Destination County`,"Migration"] * 10
#' 
#' # RUN FUNCTION
#' 
#' hierarchical_heatmap = hhm(df = od_df, ylower = "Origin County", xlower = "Destination County", yupper = "Origin Region", xupper = "Destination Region", values = "values")
#' @export
#' @importFrom dplyr "%>%"
#' @importFrom rlang sym

df = od_df
ylower = "Origin County"
xlower = "Destination County"
yupper = "Origin Region"
xupper = "Destination Region"
values = "Migration"
rm_diag = T
lgttl=NULL
bins=NULL
cbrks=NULL#od_df %>% filter(`Origin County` != `Destination County`) %>% .$Migration %>% range() %>% {seq(from = .[1], to = .[2], length.out = 10)} %>% round() %>% .[1:(length(.)-1)] #%>% {. / 68}
cclrs=viridis(11)
norm_lgd=T
lgdps=0
yttl_width = 0.22
xttl_height = 0.4

hhm = function(df,ylower,yupper,xlower,xupper,values,rm_diag=F,lgttl=NULL,bins=NULL,cbrks=NULL,cclrs=NULL,norm_lgd=F,lgdps=0,xttl_height=0.15,yttl_width=0.15) {
  
  # Define max value supplied to `values`
  if (rm_diag) {
    max_value = max(df[df[[xlower]] != df[[ylower]],values], na.rm = T)
  } else {
    max_value = max(df[[values]], na.rm = T)
  }
  
  # Check that supplied model inputs are compatible and won't cause errors
  if (!is.null(bins) && !is.null(cbrks)) { stop("The inputs bins and cbrks should not be supplied at the same time.
bins is used to break the data into a specific number of groups with equal intervals between the min and max values.
cbrks is used to manually break the data into groups based on the supplied thresholds.
Please provide either one or the other.") }
  if (!is.null(bins) && !is.null(cclrs)) {
    if (bins != length(cclrs)) { stop("If both bins and cclrs are provideds, bins and cclrs must both be vectors with cclrs having a length equal to the value of bins.") }
  }
  if (!is.null(cbrks) && rm_diag) {
    if ( (min(cbrks) <= 0) || (max(cbrks) >= max_value) ) { stop(paste0("All values in cbrks must be between 0 and the largest value provided to `values`.
In this instance rm_diag == T, so only values not on the diagonal are considered.
All values provided to cbrks should therefore be between greater than 0 and less than ",max_value,".")) }
  }
  if (!is.null(cbrks) && rm_diag == F) {
    if ( !is.null(cbrks) && (min(cbrks) <= 0) || (max(cbrks) >= max_value) ) { stop(paste0("All values in cbrks must be between 0 and the largest value provided to `values`.
In this instance all values provided to cbrks should therefore be between greater than 0 and less than ",max_value,".")) }
  }
  if (!is.null(cbrks) && !is.null(cclrs)) {
    if ( length(cbrks) != (length(cclrs)-2) ) { stop("If both cbrks and cclrs are provided, cbrks and cclrs must both be vectors with cclrs having a length two longer than cbrks.") }
  }
  if (!is.null(cbrks) && norm_lgd) {
    if (min(range(cbrks)) <  0 || max(range(cbrks)) > 1) { stop("If normalising the values (norm_lgd == T), all breaks provided to cbrks must be between 0 and 1.") }
  }
  if (cbrks %>% diff() %>% {. <= 0} %>% sum() %>% {. > 0}) { stop("Please ensure the values in cbrks are provided in ascending order.") }
  
  # Remove unwanted rows and format origin so geographies appear in alphabetical order
  df = df[,c(ylower,xlower,yupper,xupper,values)]
  
  # Define the groups to be shown along the x and y axes
  # If ordering of groups already defined via factor ordering, take this as the order 
  # the groups should appear (top to bottom / left to right). # Otherwise, order groups alphabetically
  if (!is.null(df[[xupper]] %>% levels())) {
    xgrps = df[[xupper]] %>% levels()
  } else { 
    xgrps = df[[xupper]] %>% unique() %>% sort()
  }
  if (!is.null(df[[yupper]] %>% levels())) {
    ygrps = df[[yupper]] %>% levels()
  } else { 
    ygrps = df[[yupper]] %>% unique() %>% sort()
  }
  
  # If user specified to remove diagonal values, set all observations where ylower and xlower are identical to zero
  if (rm_diag) {
    df[df[[ylower]] == df[[xlower]],values] = NA
  }
  
  # Option to normalise values between 0-1 (only works if all values are positive)
  if (norm_lgd) {
    
    # If any values are negative, return error message
    if ((df[[values]] < 0) %>% sum(na.rm = T) %>% {. > 0}) {stop("norm_lgd is only designed to be used if all values used to populate the heatmap are positive.")}
    
    # Otherwise normalise values
    df[[values]] = df[[values]] / max(df[[values]], na.rm = T)
    
    # Unless a value other than zero is supplied (i.e. the user has manually specified a non-default value), set the number of decimal points shown in the legend to 3
    if (lgdps == 0) {
      lgdps = 3
    }
  }
  
  # Option to split legend into custom categories
  if (!is.null(cbrks)) { # If cbrks provided
    
    # Add the smallest value possible in R as a lower threshold to cbrks. 
    # This ensures anything that is equal to, or less than, zero is included in the first group.
    cbrks = c(.Machine$double.xmin,cbrks)
    
    # Define names of custom breaks
    if (lgdps == 0) {
      brk_nms = c(0, paste(cbrks %>% .[2:length(.)] %>% c(0,.        ), 
                           cbrks %>% .[2:length(.)] %>% c(.,max_value), 
                           sep = "-"))
    } else if (norm_lgd) {
      brk_nms = c(0, paste(cbrks %>% .[2:length(.)] %>% c(0,.        ) %>% sprintf(fmt = paste0('%#.',lgdps,'f')), 
                           cbrks %>% .[2:length(.)] %>% c(.,1        ) %>% sprintf(fmt = paste0('%#.',lgdps,'f')), 
                           sep = "-"))
    } else {
      brk_nms = c(0, paste(cbrks %>% .[2:length(.)] %>% c(0,.        ) %>% sprintf(fmt = paste0('%#.',lgdps,'f')), 
                           cbrks %>% .[2:length(.)] %>% c(.,max_value) %>% sprintf(fmt = paste0('%#.',lgdps,'f')), 
                           sep = "-"))
    }
  
    # Create discrete scale based on these custom breaks
    df[[values]] = df[[values]] %>% findInterval(cbrks) %>% {. + 1} %>% addNA() %>% 
                                    factor(levels = 1:length(brk_nms), labels = brk_nms)
    
  } else if (!is.null(bins)) { # If bins provided
    
    # Assign breaks to be equidistant thresholds between the minimum and maximum observed values
    cbrks = seq(min(df[[values]], na.rm = T), max(df[[values]], na.rm = T), length.out = bins - 1) %>% .[1:(length(.)-1)] %>% c(.Machine$double.xmin,.)
    
    # Define names of custom breaks
    if (lgdps == 0) {
      brk_nms = c(0, paste(cbrks %>% .[2:length(.)] %>% c(0,.        ), 
                           cbrks %>% .[2:length(.)] %>% c(.,max_value), 
                           sep = "-"))
    } else if (norm_lgd) {
      brk_nms = c(0, paste(cbrks %>% .[2:length(.)] %>% c(0,.        ) %>% sprintf(fmt = paste0('%#.',lgdps,'f')), 
                           cbrks %>% .[2:length(.)] %>% c(.,1        ) %>% sprintf(fmt = paste0('%#.',lgdps,'f')), 
                           sep = "-"))
    } else {
      brk_nms = c(0, paste(cbrks %>% .[2:length(.)] %>% c(0,.        ) %>% sprintf(fmt = paste0('%#.',lgdps,'f')), 
                           cbrks %>% .[2:length(.)] %>% c(.,max_value) %>% sprintf(fmt = paste0('%#.',lgdps,'f')), 
                           sep = "-"))
    }
  
    # Create discrete scale based on these custom breaks
    df[[values]] = df[[values]] %>% findInterval(cbrks) %>% 
                                    replace(. == length(cbrks), (length(cbrks)-.Machine$double.xmin)) %>% 
                                    {. + 1} %>% addNA() %>% 
                                    factor(levels = 1:length(brk_nms), labels = brk_nms)
    
  } else { # Otherwise define consistent legend scale range
    lg_lims = df[[values]] %>% range(na.rm = T)
  }
  
  # Define legend title (if not defined by user)
  if (is.null(lgttl) && norm_lgd) {
    lgttl = "Normalised\nValues"
  } else if (is.null(lgttl) && norm_lgd == F) {
    lgttl = "Values"
  }
  
  # Create empty list to populate with ggplot heatmaps
  pl = list()
  
  # Define vectors capturing the number of lower categories in each upper group
  xglns = df %>% group_split(!!rlang::sym(xupper)) %>% map(~ .[[xlower]] %>% unique() %>% length()) %>% unlist()
  yglns = df %>% group_split(!!rlang::sym(yupper)) %>% map(~ .[[ylower]] %>% unique() %>% length()) %>% unlist()
  
  # Counter to keep track of interations of nested for loop
  i = 0
  
  # For each y-axis group
  for (ygrp in 1:length(ygrps)) {
    
    # For each x-axis group
    for (xgrp in 1:length(xgrps)) {
      
      # Increase interature counter by 1
      i = i + 1
      
      # Filter group-level migration data to only include origin and destination regions of interest
      sdf = df[df[[yupper]] == ygrps[ygrp] & df[[xupper]] == xgrps[xgrp],]
      
      # Order lower categories alphabetically
      sdf[[xlower]] = factor(sdf[[xlower]], levels = sdf[[xlower]] %>% unique() %>% sort()           )
      sdf[[ylower]] = factor(sdf[[ylower]], levels = sdf[[ylower]] %>% unique() %>% sort() %>% rev() )
      
      # Define main plot
      p = ggplot(sdf, aes(.data[[xlower]], .data[[ylower]])) +
        geom_tile(aes(fill = .data[[values]]), show.legend = T) +
        theme(plot.margin = unit(rep(0,4), "cm"),
              axis.text.x  = element_text(angle = 90, hjust = 1.0, vjust = 0.3),
              axis.title.x = element_text(angle = 90, hjust = 0.5, vjust = 0.5),
              axis.title.y = element_text(angle =  0, hjust = 0.5, vjust = 0.5),
              axis.ticks   = element_blank()) +
        labs(x = xgrps[xgrp], y = ygrps[ygrp])
      
      # Define colour scale
      if (!is.null(cbrks) && !is.null(cclrs)) {
        p = p + scale_fill_manual(name = lgttl, values = cclrs                                  , drop = F, na.value = "white")
      } else if (!is.null(cbrks) && is.null(cclrs)) {
        p = p + scale_fill_manual(name = lgttl, values = cg("white","#08306B",(length(cbrks)+1)), drop = F, na.value = "white")
      } else if (is.null(cbrks) && !is.null(cclrs) && norm_lgd) {
        p = p + scale_fill_gradientn(name = lgttl, colours = cclrs                , limits = c(0,1) , na.value = "white")
      } else if (is.null(cbrks) && !is.null(cclrs) && norm_lgd == F) {
        p = p + scale_fill_gradientn(name = lgttl, colours = cclrs                , limits = lg_lims, na.value = "white")
      } else if (is.null(cbrks) && is.null(cclrs) && norm_lgd) {
        p = p + scale_fill_gradientn(name = lgttl, colours = cg("white","#08306B"), limits = c(0,1) , na.value = "white")
      } else if (is.null(cbrks) && is.null(cclrs) && norm_lgd == F) {
        p = p + scale_fill_gradientn(name = lgttl, colours = cg("white","#08306B"), limits = lg_lims, na.value = "white")
      }
      
      # To prevent legend showing NA values if rm_diag set to TRUE (in which case, diagonal set to NA), only show legend for plots that are not on the diagonal
      if (rm_diag && (sdf[[values]] %>% is.na() %>% sum() %>% {. > 0}) && (ygrp == xgrp) ) {
        p = p + theme(legend.position = "none")
      }
      
      # If bottom-left plot
      if (ygrp == length(ygrps) & xgrp == 1) {
        # Include provincia names on both axes
        p = p + theme(axis.title.x = element_blank(),
                      axis.title.y = element_blank())
      } else if (ygrp < length(ygrps) & xgrp == 1) { # If left-hand plot
        # Include provincia names on y-axis
        p = p + theme(axis.title.x = element_blank(),
                      axis.title.y = element_blank(),
                      axis.text.x  = element_blank())
      } else if (ygrp == length(ygrps) & xgrp > 1) { # If bottom plot
        # Include provincia names on x-axis
        p = p + theme(axis.title.x = element_blank(),
                      axis.title.y = element_blank(),
                      axis.text.y  = element_blank())
      } else { # If plot not on left of bottom edges of multiplot
        # Remove provincia names
        p = p + theme(axis.title.x = element_blank(),
                      axis.title.y = element_blank(),
                      axis.text.x  = element_blank(),
                      axis.text.y  = element_blank())
      }
      
      # Add ggplot to plot list
      pl[[i]] = p
      
    }
    
  }
  
  # Define plot heights and widths (including group titles)
  wds = c((sum(xglns)*yttl_width),xglns)
  hts = c(yglns,(sum(yglns)*xttl_height))
  
  # Define plot spacer
  ps = plot_spacer()
  
  # Create empty lists to be populated with plot titles
  xttls = list()
  yttls = list()
  
  # Define plot titles
  for (xgrp in 1:length(xgrps)) {
    xttls[[xgrp]] = plt_ttl(xgrps[xgrp])
  }
  for (ygrp in 1:length(ygrps)) {
    yttls[[ygrp]] = plt_ttl(ygrps[ygrp],axs="y")
  }
  
  # Create empty list to populate with both plot title and heatmap tiles in the correct order
  plts = list()
  
  # Define counters for subsetting plot title and heatmap lists, to ensure they are ordered correctly
  i = 1
  j = 1
  
  # For each group (row), assign each plot title, then the heatmap tiles within that row to plts list
  for (ygrp in 1:length(yttls)) {
    
    # Add plot title to list
    plts[[i]] = yttls[[ygrp]]
    
    # Add heatmap plots to list
    plts[(i+1):(i+length(xttls))] = pl[j:(j+length(xttls)-1)]
    
    # Adjust counters
    i = i + 1 + length(xttls)
    j = j +     length(xttls)
  }
  
  # Add x-axis plots
  plts[[length(plts)+1]] = ps
  plts[(length(plts)+1):(length(plts)+length(xttls))] = xttls
  
  # Define final plot
  plt = patchwork::wrap_plots(plts, widths = wds, heights = hts, guides = "collect")

  # Return final plot
  return(plt)
}
```



```{r}
# Define patchwork plot based on number of groups on x and y axis (can plot up to 20 groups in each axis)
if (length(xgrps) == 1 & length(ygrps) == 1) {
  plt = yttl1 +pl[[1]]+ 
        ps    +xttl1  + 
        plot_layout(widths = wds, heights = hts, guides = "collect")
} else if (length(xglns) == 2 & length(yglns) == 1) {
  plt = yttl1 +pl[[  1]]+pl[[  2]]+
        ps    +xttl1    +xttl2    +
        plot_layout(widths = wds, heights = hts, guides = "collect")
} else if (length(xglns) == 3 & length(yglns) == 1) {
  plt = yttl1 +pl[[  1]]+pl[[  2]]+pl[[  3]]+
        ps    +xttl1    +xttl2    +xttl3    +
        plot_layout(widths = wds, heights = hts, guides = "collect")
} else if (length(xglns) == 4 & length(yglns) == 1) {
  plt = yttl1 +pl[[  1]]+pl[[  2]]+pl[[  3]]+pl[[  4]]+
        ps    +xttl1    +xttl2    +xttl3    +xttl4    +
        plot_layout(widths = wds, heights = hts, guides = "collect")
} else if (length(xglns) == 5 & length(yglns) == 1) {
  plt = yttl1 +pl[[  1]]+pl[[  2]]+pl[[  3]]+pl[[  4]]+pl[[  5]]+
        ps    +xttl1    +xttl2    +xttl3    +xttl4    +xttl5    +
        plot_layout(widths = wds, heights = hts, guides = "collect")
} else if (length(xglns) == 6 & length(yglns) == 1) {
  plt = yttl1 +pl[[  1]]+pl[[  2]]+pl[[  3]]+pl[[  4]]+pl[[  5]]+pl[[  6]]+
        ps    +xttl1    +xttl2    +xttl3    +xttl4    +xttl5    +xttl6    +
        plot_layout(widths = wds, heights = hts, guides = "collect")
} else if (length(xglns) == 7 & length(yglns) == 1) {
  plt = yttl1 +pl[[  1]]+pl[[  2]]+pl[[  3]]+pl[[  4]]+pl[[  5]]+pl[[  6]]+pl[[  7]]+
        ps    +xttl1    +xttl2    +xttl3    +xttl4    +xttl5    +xttl6    +xttl7    +
        plot_layout(widths = wds, heights = hts, guides = "collect")
} else if (length(xglns) == 8 & length(yglns) == 1) {
  plt = yttl1 +pl[[  1]]+pl[[  2]]+pl[[  3]]+pl[[  4]]+pl[[  5]]+pl[[  6]]+pl[[  7]]+pl[[  8]]+
        ps    +xttl1    +xttl2    +xttl3    +xttl4    +xttl5    +xttl6    +xttl7    +xttl8    +
        plot_layout(widths = wds, heights = hts, guides = "collect")
} else if (length(xglns) == 9 & length(yglns) == 1) {
  plt = yttl1 +pl[[  1]]+pl[[  2]]+pl[[  3]]+pl[[  4]]+pl[[  5]]+pl[[  6]]+pl[[  7]]+pl[[  8]]+pl[[  9]]+
        ps    +xttl1    +xttl2    +xttl3    +xttl4    +xttl5    +xttl6    +xttl7    +xttl8    +xttl9    +
        plot_layout(widths = wds, heights = hts, guides = "collect")
} else if (length(xglns) == 10 & length(yglns) == 1) {
  plt = yttl1 +pl[[  1]]+pl[[  2]]+pl[[  3]]+pl[[  4]]+pl[[  5]]+pl[[  6]]+pl[[  7]]+pl[[  8]]+pl[[  9]]+pl[[ 10]]+
        ps    +xttl1    +xttl2    +xttl3    +xttl4    +xttl5    +xttl6    +xttl7    +xttl8    +xttl9    +xttl10   +
        plot_layout(widths = wds, heights = hts, guides = "collect")
} else if (length(xglns) == 11 & length(yglns) == 1) {
  plt = yttl1 +pl[[  1]]+pl[[  2]]+pl[[  3]]+pl[[  4]]+pl[[  5]]+pl[[  6]]+pl[[  7]]+pl[[  8]]+pl[[  9]]+pl[[ 10]]+pl[[ 11]]+
        ps    +xttl1    +xttl2    +xttl3    +xttl4    +xttl5    +xttl6    +xttl7    +xttl8    +xttl9    +xttl10   +xttl11   +
        plot_layout(widths = wds, heights = hts, guides = "collect")
} else if (length(xglns) == 12 & length(yglns) == 1) {
  plt = yttl1 +pl[[  1]]+pl[[  2]]+pl[[  3]]+pl[[  4]]+pl[[  5]]+pl[[  6]]+pl[[  7]]+pl[[  8]]+pl[[  9]]+pl[[ 10]]+pl[[ 11]]+pl[[ 12]]+
        ps    +xttl1    +xttl2    +xttl3    +xttl4    +xttl5    +xttl6    +xttl7    +xttl8    +xttl9    +xttl10   +xttl11   +xttl12   +
        plot_layout(widths = wds, heights = hts, guides = "collect")
} else if (length(xglns) == 13 & length(yglns) == 1) {
  plt = yttl1 +pl[[  1]]+pl[[  2]]+pl[[  3]]+pl[[  4]]+pl[[  5]]+pl[[  6]]+pl[[  7]]+pl[[  8]]+pl[[  9]]+pl[[ 10]]+pl[[ 11]]+pl[[ 12]]+pl[[ 13]]+
        ps    +xttl1    +xttl2    +xttl3    +xttl4    +xttl5    +xttl6    +xttl7    +xttl8    +xttl9    +xttl10   +xttl11   +xttl12   +xttl13   +
        plot_layout(widths = wds, heights = hts, guides = "collect")
} else if (length(xglns) == 14 & length(yglns) == 1) {
  plt = yttl1 +pl[[  1]]+pl[[  2]]+pl[[  3]]+pl[[  4]]+pl[[  5]]+pl[[  6]]+pl[[  7]]+pl[[  8]]+pl[[  9]]+pl[[ 10]]+pl[[ 11]]+pl[[ 12]]+pl[[ 13]]+pl[[ 14]]+
        ps    +xttl1    +xttl2    +xttl3    +xttl4    +xttl5    +xttl6    +xttl7    +xttl8    +xttl9    +xttl10   +xttl11   +xttl12   +xttl13   +xttl14   +
        plot_layout(widths = wds, heights = hts, guides = "collect")
} else if (length(xglns) == 15 & length(yglns) == 1) {
  plt = yttl1 +pl[[  1]]+pl[[  2]]+pl[[  3]]+pl[[  4]]+pl[[  5]]+pl[[  6]]+pl[[  7]]+pl[[  8]]+pl[[  9]]+pl[[ 10]]+pl[[ 11]]+pl[[ 12]]+pl[[ 13]]+pl[[ 14]]+pl[[ 15]]+
        ps    +xttl1    +xttl2    +xttl3    +xttl4    +xttl5    +xttl6    +xttl7    +xttl8    +xttl9    +xttl10   +xttl11   +xttl12   +xttl13   +xttl14   +xttl15   +
        plot_layout(widths = wds, heights = hts, guides = "collect")
} else if (length(xglns) == 16 & length(yglns) == 1) {
  plt = yttl1 +pl[[  1]]+pl[[  2]]+pl[[  3]]+pl[[  4]]+pl[[  5]]+pl[[  6]]+pl[[  7]]+pl[[  8]]+pl[[  9]]+pl[[ 10]]+pl[[ 11]]+pl[[ 12]]+pl[[ 13]]+pl[[ 14]]+pl[[ 15]]+pl[[ 16]]+
        ps    +xttl1    +xttl2    +xttl3    +xttl4    +xttl5    +xttl6    +xttl7    +xttl8    +xttl9    +xttl10   +xttl11   +xttl12   +xttl13   +xttl14   +xttl15   +xttl16   +
        plot_layout(widths = wds, heights = hts, guides = "collect")
} else if (length(xglns) == 17 & length(yglns) == 1) {
  plt = yttl1 +pl[[  1]]+pl[[  2]]+pl[[  3]]+pl[[  4]]+pl[[  5]]+pl[[  6]]+pl[[  7]]+pl[[  8]]+pl[[  9]]+pl[[ 10]]+pl[[ 11]]+pl[[ 12]]+pl[[ 13]]+pl[[ 14]]+pl[[ 15]]+pl[[ 16]]+pl[[ 17]]+
        ps    +xttl1    +xttl2    +xttl3    +xttl4    +xttl5    +xttl6    +xttl7    +xttl8    +xttl9    +xttl10   +xttl11   +xttl12   +xttl13   +xttl14   +xttl15   +xttl16   +xttl17   +
        plot_layout(widths = wds, heights = hts, guides = "collect")
} else if (length(xglns) == 18 & length(yglns) == 1) {
  plt = yttl1 +pl[[  1]]+pl[[  2]]+pl[[  3]]+pl[[  4]]+pl[[  5]]+pl[[  6]]+pl[[  7]]+pl[[  8]]+pl[[  9]]+pl[[ 10]]+pl[[ 11]]+pl[[ 12]]+pl[[ 13]]+pl[[ 14]]+pl[[ 15]]+pl[[ 16]]+pl[[ 17]]+pl[[ 18]]+
        ps    +xttl1    +xttl2    +xttl3    +xttl4    +xttl5    +xttl6    +xttl7    +xttl8    +xttl9    +xttl10   +xttl11   +xttl12   +xttl13   +xttl14   +xttl15   +xttl16   +xttl17   +xttl18   +
        plot_layout(widths = wds, heights = hts, guides = "collect")
} else if (length(xglns) == 19 & length(yglns) == 1) {
  plt = yttl1 +pl[[  1]]+pl[[  2]]+pl[[  3]]+pl[[  4]]+pl[[  5]]+pl[[  6]]+pl[[  7]]+pl[[  8]]+pl[[  9]]+pl[[ 10]]+pl[[ 11]]+pl[[ 12]]+pl[[ 13]]+pl[[ 14]]+pl[[ 15]]+pl[[ 16]]+pl[[ 17]]+pl[[ 18]]+pl[[ 19]]+
        ps    +xttl1    +xttl2    +xttl3    +xttl4    +xttl5    +xttl6    +xttl7    +xttl8    +xttl9    +xttl10   +xttl11   +xttl12   +xttl13   +xttl14   +xttl15   +xttl16   +xttl17   +xttl18   +xttl19   +
        plot_layout(widths = wds, heights = hts, guides = "collect")
} else if (length(xglns) == 20 & length(yglns) == 1) {
  plt = yttl1 +pl[[  1]]+pl[[  2]]+pl[[  3]]+pl[[  4]]+pl[[  5]]+pl[[  6]]+pl[[  7]]+pl[[  8]]+pl[[  9]]+pl[[ 10]]+pl[[ 11]]+pl[[ 12]]+pl[[ 13]]+pl[[ 14]]+pl[[ 15]]+pl[[ 16]]+pl[[ 17]]+pl[[ 18]]+pl[[ 19]]+pl[[ 20]]+
        ps    +xttl1    +xttl2    +xttl3    +xttl4    +xttl5    +xttl6    +xttl7    +xttl8    +xttl9    +xttl10   +xttl11   +xttl12   +xttl13   +xttl14   +xttl15   +xttl16   +xttl17   +xttl18   +xttl19   +xttl20   +
        plot_layout(widths = wds, heights = hts, guides = "collect")
}



 else if (length(xglns) == 19 & length(yglns) == 20) {
  plt = yttl1 +pl[[  1]]+pl[[  2]]+pl[[  3]]+pl[[  4]]+pl[[  5]]+pl[[  6]]+pl[[  7]]+pl[[  8]]+pl[[  9]]+pl[[ 10]]+pl[[ 11]]+pl[[ 12]]+pl[[ 13]]+pl[[ 14]]+pl[[ 15]]+pl[[ 16]]+pl[[ 17]]+pl[[ 18]]+pl[[ 19]]+pl[[ 20]]+
        yttl2 +pl[[ 21]]+pl[[ 22]]+pl[[ 23]]+pl[[ 24]]+pl[[ 25]]+pl[[ 26]]+pl[[ 27]]+pl[[ 28]]+pl[[ 29]]+pl[[ 30]]+pl[[ 31]]+pl[[ 32]]+pl[[ 33]]+pl[[ 34]]+pl[[ 35]]+pl[[ 36]]+pl[[ 37]]+pl[[ 38]]+pl[[ 39]]+pl[[ 40]]+
        yttl3 +pl[[ 41]]+pl[[ 42]]+pl[[ 43]]+pl[[ 44]]+pl[[ 45]]+pl[[ 46]]+pl[[ 47]]+pl[[ 48]]+pl[[ 49]]+pl[[ 50]]+pl[[ 51]]+pl[[ 52]]+pl[[ 53]]+pl[[ 54]]+pl[[ 55]]+pl[[ 56]]+pl[[ 57]]+pl[[ 58]]+pl[[ 59]]+pl[[ 60]]+
        yttl4 +pl[[ 61]]+pl[[ 62]]+pl[[ 63]]+pl[[ 64]]+pl[[ 65]]+pl[[ 66]]+pl[[ 67]]+pl[[ 68]]+pl[[ 69]]+pl[[ 70]]+pl[[ 71]]+pl[[ 72]]+pl[[ 73]]+pl[[ 74]]+pl[[ 75]]+pl[[ 76]]+pl[[ 77]]+pl[[ 78]]+pl[[ 79]]+pl[[ 80]]+
        yttl5 +pl[[ 81]]+pl[[ 82]]+pl[[ 83]]+pl[[ 84]]+pl[[ 85]]+pl[[ 86]]+pl[[ 87]]+pl[[ 88]]+pl[[ 89]]+pl[[ 90]]+pl[[ 91]]+pl[[ 92]]+pl[[ 93]]+pl[[ 94]]+pl[[ 95]]+pl[[ 96]]+pl[[ 97]]+pl[[ 98]]+pl[[ 99]]+pl[[100]]+
        yttl6 +pl[[101]]+pl[[102]]+pl[[103]]+pl[[104]]+pl[[105]]+pl[[106]]+pl[[107]]+pl[[108]]+pl[[109]]+pl[[110]]+pl[[111]]+pl[[112]]+pl[[113]]+pl[[114]]+pl[[115]]+pl[[116]]+pl[[117]]+pl[[118]]+pl[[119]]+pl[[120]]+
        yttl7 +pl[[121]]+pl[[122]]+pl[[123]]+pl[[124]]+pl[[125]]+pl[[126]]+pl[[127]]+pl[[128]]+pl[[129]]+pl[[130]]+pl[[131]]+pl[[132]]+pl[[133]]+pl[[134]]+pl[[135]]+pl[[136]]+pl[[137]]+pl[[138]]+pl[[139]]+pl[[140]]+
        yttl8 +pl[[141]]+pl[[142]]+pl[[143]]+pl[[144]]+pl[[145]]+pl[[146]]+pl[[147]]+pl[[148]]+pl[[149]]+pl[[150]]+pl[[151]]+pl[[152]]+pl[[153]]+pl[[154]]+pl[[155]]+pl[[156]]+pl[[157]]+pl[[158]]+pl[[159]]+pl[[160]]+
        yttl9 +pl[[161]]+pl[[162]]+pl[[163]]+pl[[164]]+pl[[165]]+pl[[166]]+pl[[167]]+pl[[168]]+pl[[169]]+pl[[170]]+pl[[171]]+pl[[172]]+pl[[173]]+pl[[174]]+pl[[175]]+pl[[176]]+pl[[177]]+pl[[178]]+pl[[179]]+pl[[180]]+
        yttl10+pl[[181]]+pl[[182]]+pl[[183]]+pl[[184]]+pl[[185]]+pl[[186]]+pl[[187]]+pl[[188]]+pl[[189]]+pl[[190]]+pl[[191]]+pl[[192]]+pl[[193]]+pl[[194]]+pl[[195]]+pl[[196]]+pl[[197]]+pl[[198]]+pl[[199]]+pl[[200]]+
        yttl11+pl[[201]]+pl[[202]]+pl[[203]]+pl[[204]]+pl[[205]]+pl[[206]]+pl[[207]]+pl[[208]]+pl[[209]]+pl[[210]]+pl[[211]]+pl[[212]]+pl[[213]]+pl[[214]]+pl[[215]]+pl[[216]]+pl[[217]]+pl[[218]]+pl[[219]]+pl[[220]]+
        yttl12+pl[[221]]+pl[[222]]+pl[[223]]+pl[[224]]+pl[[225]]+pl[[226]]+pl[[227]]+pl[[228]]+pl[[229]]+pl[[230]]+pl[[231]]+pl[[232]]+pl[[233]]+pl[[234]]+pl[[235]]+pl[[236]]+pl[[237]]+pl[[238]]+pl[[239]]+pl[[240]]+
        yttl13+pl[[241]]+pl[[242]]+pl[[243]]+pl[[244]]+pl[[245]]+pl[[246]]+pl[[247]]+pl[[248]]+pl[[249]]+pl[[250]]+pl[[251]]+pl[[252]]+pl[[253]]+pl[[254]]+pl[[255]]+pl[[256]]+pl[[257]]+pl[[258]]+pl[[259]]+pl[[260]]+
        yttl14+pl[[261]]+pl[[262]]+pl[[263]]+pl[[264]]+pl[[265]]+pl[[266]]+pl[[267]]+pl[[268]]+pl[[269]]+pl[[270]]+pl[[271]]+pl[[272]]+pl[[273]]+pl[[274]]+pl[[275]]+pl[[276]]+pl[[277]]+pl[[278]]+pl[[279]]+pl[[280]]+
        yttl15+pl[[281]]+pl[[282]]+pl[[283]]+pl[[284]]+pl[[285]]+pl[[286]]+pl[[287]]+pl[[288]]+pl[[289]]+pl[[290]]+pl[[291]]+pl[[292]]+pl[[293]]+pl[[294]]+pl[[295]]+pl[[296]]+pl[[297]]+pl[[298]]+pl[[299]]+pl[[300]]+
        yttl16+pl[[301]]+pl[[302]]+pl[[303]]+pl[[304]]+pl[[305]]+pl[[306]]+pl[[307]]+pl[[308]]+pl[[309]]+pl[[310]]+pl[[311]]+pl[[312]]+pl[[313]]+pl[[314]]+pl[[315]]+pl[[316]]+pl[[317]]+pl[[318]]+pl[[319]]+pl[[320]]+
        yttl17+pl[[321]]+pl[[322]]+pl[[323]]+pl[[324]]+pl[[325]]+pl[[326]]+pl[[327]]+pl[[328]]+pl[[329]]+pl[[330]]+pl[[331]]+pl[[332]]+pl[[333]]+pl[[334]]+pl[[335]]+pl[[336]]+pl[[337]]+pl[[338]]+pl[[339]]+pl[[340]]+
        yttl18+pl[[341]]+pl[[342]]+pl[[343]]+pl[[344]]+pl[[345]]+pl[[346]]+pl[[347]]+pl[[348]]+pl[[349]]+pl[[350]]+pl[[351]]+pl[[352]]+pl[[353]]+pl[[354]]+pl[[355]]+pl[[356]]+pl[[357]]+pl[[358]]+pl[[359]]+pl[[360]]+
        yttl19+pl[[361]]+pl[[362]]+pl[[363]]+pl[[364]]+pl[[365]]+pl[[366]]+pl[[367]]+pl[[368]]+pl[[369]]+pl[[370]]+pl[[371]]+pl[[372]]+pl[[373]]+pl[[374]]+pl[[375]]+pl[[376]]+pl[[377]]+pl[[378]]+pl[[379]]+pl[[380]]+
        yttl20+pl[[381]]+pl[[382]]+pl[[383]]+pl[[384]]+pl[[385]]+pl[[386]]+pl[[387]]+pl[[388]]+pl[[389]]+pl[[390]]+pl[[391]]+pl[[392]]+pl[[393]]+pl[[394]]+pl[[395]]+pl[[396]]+pl[[397]]+pl[[398]]+pl[[399]]+pl[[400]]+
        ps    +xttl1    +xttl2    +xttl3    +xttl4    +xttl5    +xttl6    +xttl7    +xttl8    +xttl9    +xttl10   +xttl11   +xttl12   +xttl13   +xttl14   +xttl15   +xttl16   +xttl17   +xttl18   +xttl19   +xttl20   +
        plot_layout(widths = wds, heights = hts, guides = "collect")
} else if (length(xglns) == 20 & length(yglns) == 20) {
  plt = yttl1 +pl[[  1]]+pl[[  2]]+pl[[  3]]+pl[[  4]]+pl[[  5]]+pl[[  6]]+pl[[  7]]+pl[[  8]]+pl[[  9]]+pl[[ 10]]+pl[[ 11]]+pl[[ 12]]+pl[[ 13]]+pl[[ 14]]+pl[[ 15]]+pl[[ 16]]+pl[[ 17]]+pl[[ 18]]+pl[[ 19]]+pl[[ 20]]+
        yttl2 +pl[[ 21]]+pl[[ 22]]+pl[[ 23]]+pl[[ 24]]+pl[[ 25]]+pl[[ 26]]+pl[[ 27]]+pl[[ 28]]+pl[[ 29]]+pl[[ 30]]+pl[[ 31]]+pl[[ 32]]+pl[[ 33]]+pl[[ 34]]+pl[[ 35]]+pl[[ 36]]+pl[[ 37]]+pl[[ 38]]+pl[[ 39]]+pl[[ 40]]+
        yttl3 +pl[[ 41]]+pl[[ 42]]+pl[[ 43]]+pl[[ 44]]+pl[[ 45]]+pl[[ 46]]+pl[[ 47]]+pl[[ 48]]+pl[[ 49]]+pl[[ 50]]+pl[[ 51]]+pl[[ 52]]+pl[[ 53]]+pl[[ 54]]+pl[[ 55]]+pl[[ 56]]+pl[[ 57]]+pl[[ 58]]+pl[[ 59]]+pl[[ 60]]+
        yttl4 +pl[[ 61]]+pl[[ 62]]+pl[[ 63]]+pl[[ 64]]+pl[[ 65]]+pl[[ 66]]+pl[[ 67]]+pl[[ 68]]+pl[[ 69]]+pl[[ 70]]+pl[[ 71]]+pl[[ 72]]+pl[[ 73]]+pl[[ 74]]+pl[[ 75]]+pl[[ 76]]+pl[[ 77]]+pl[[ 78]]+pl[[ 79]]+pl[[ 80]]+
        yttl5 +pl[[ 81]]+pl[[ 82]]+pl[[ 83]]+pl[[ 84]]+pl[[ 85]]+pl[[ 86]]+pl[[ 87]]+pl[[ 88]]+pl[[ 89]]+pl[[ 90]]+pl[[ 91]]+pl[[ 92]]+pl[[ 93]]+pl[[ 94]]+pl[[ 95]]+pl[[ 96]]+pl[[ 97]]+pl[[ 98]]+pl[[ 99]]+pl[[100]]+
        yttl6 +pl[[101]]+pl[[102]]+pl[[103]]+pl[[104]]+pl[[105]]+pl[[106]]+pl[[107]]+pl[[108]]+pl[[109]]+pl[[110]]+pl[[111]]+pl[[112]]+pl[[113]]+pl[[114]]+pl[[115]]+pl[[116]]+pl[[117]]+pl[[118]]+pl[[119]]+pl[[120]]+
        yttl7 +pl[[121]]+pl[[122]]+pl[[123]]+pl[[124]]+pl[[125]]+pl[[126]]+pl[[127]]+pl[[128]]+pl[[129]]+pl[[130]]+pl[[131]]+pl[[132]]+pl[[133]]+pl[[134]]+pl[[135]]+pl[[136]]+pl[[137]]+pl[[138]]+pl[[139]]+pl[[140]]+
        yttl8 +pl[[141]]+pl[[142]]+pl[[143]]+pl[[144]]+pl[[145]]+pl[[146]]+pl[[147]]+pl[[148]]+pl[[149]]+pl[[150]]+pl[[151]]+pl[[152]]+pl[[153]]+pl[[154]]+pl[[155]]+pl[[156]]+pl[[157]]+pl[[158]]+pl[[159]]+pl[[160]]+
        yttl9 +pl[[161]]+pl[[162]]+pl[[163]]+pl[[164]]+pl[[165]]+pl[[166]]+pl[[167]]+pl[[168]]+pl[[169]]+pl[[170]]+pl[[171]]+pl[[172]]+pl[[173]]+pl[[174]]+pl[[175]]+pl[[176]]+pl[[177]]+pl[[178]]+pl[[179]]+pl[[180]]+
        yttl10+pl[[181]]+pl[[182]]+pl[[183]]+pl[[184]]+pl[[185]]+pl[[186]]+pl[[187]]+pl[[188]]+pl[[189]]+pl[[190]]+pl[[191]]+pl[[192]]+pl[[193]]+pl[[194]]+pl[[195]]+pl[[196]]+pl[[197]]+pl[[198]]+pl[[199]]+pl[[200]]+
        yttl11+pl[[201]]+pl[[202]]+pl[[203]]+pl[[204]]+pl[[205]]+pl[[206]]+pl[[207]]+pl[[208]]+pl[[209]]+pl[[210]]+pl[[211]]+pl[[212]]+pl[[213]]+pl[[214]]+pl[[215]]+pl[[216]]+pl[[217]]+pl[[218]]+pl[[219]]+pl[[220]]+
        yttl12+pl[[221]]+pl[[222]]+pl[[223]]+pl[[224]]+pl[[225]]+pl[[226]]+pl[[227]]+pl[[228]]+pl[[229]]+pl[[230]]+pl[[231]]+pl[[232]]+pl[[233]]+pl[[234]]+pl[[235]]+pl[[236]]+pl[[237]]+pl[[238]]+pl[[239]]+pl[[240]]+
        yttl13+pl[[241]]+pl[[242]]+pl[[243]]+pl[[244]]+pl[[245]]+pl[[246]]+pl[[247]]+pl[[248]]+pl[[249]]+pl[[250]]+pl[[251]]+pl[[252]]+pl[[253]]+pl[[254]]+pl[[255]]+pl[[256]]+pl[[257]]+pl[[258]]+pl[[259]]+pl[[260]]+
        yttl14+pl[[261]]+pl[[262]]+pl[[263]]+pl[[264]]+pl[[265]]+pl[[266]]+pl[[267]]+pl[[268]]+pl[[269]]+pl[[270]]+pl[[271]]+pl[[272]]+pl[[273]]+pl[[274]]+pl[[275]]+pl[[276]]+pl[[277]]+pl[[278]]+pl[[279]]+pl[[280]]+
        yttl15+pl[[281]]+pl[[282]]+pl[[283]]+pl[[284]]+pl[[285]]+pl[[286]]+pl[[287]]+pl[[288]]+pl[[289]]+pl[[290]]+pl[[291]]+pl[[292]]+pl[[293]]+pl[[294]]+pl[[295]]+pl[[296]]+pl[[297]]+pl[[298]]+pl[[299]]+pl[[300]]+
        yttl16+pl[[301]]+pl[[302]]+pl[[303]]+pl[[304]]+pl[[305]]+pl[[306]]+pl[[307]]+pl[[308]]+pl[[309]]+pl[[310]]+pl[[311]]+pl[[312]]+pl[[313]]+pl[[314]]+pl[[315]]+pl[[316]]+pl[[317]]+pl[[318]]+pl[[319]]+pl[[320]]+
        yttl17+pl[[321]]+pl[[322]]+pl[[323]]+pl[[324]]+pl[[325]]+pl[[326]]+pl[[327]]+pl[[328]]+pl[[329]]+pl[[330]]+pl[[331]]+pl[[332]]+pl[[333]]+pl[[334]]+pl[[335]]+pl[[336]]+pl[[337]]+pl[[338]]+pl[[339]]+pl[[340]]+
        yttl18+pl[[341]]+pl[[342]]+pl[[343]]+pl[[344]]+pl[[345]]+pl[[346]]+pl[[347]]+pl[[348]]+pl[[349]]+pl[[350]]+pl[[351]]+pl[[352]]+pl[[353]]+pl[[354]]+pl[[355]]+pl[[356]]+pl[[357]]+pl[[358]]+pl[[359]]+pl[[360]]+
        yttl19+pl[[361]]+pl[[362]]+pl[[363]]+pl[[364]]+pl[[365]]+pl[[366]]+pl[[367]]+pl[[368]]+pl[[369]]+pl[[370]]+pl[[371]]+pl[[372]]+pl[[373]]+pl[[374]]+pl[[375]]+pl[[376]]+pl[[377]]+pl[[378]]+pl[[379]]+pl[[380]]+
        yttl20+pl[[381]]+pl[[382]]+pl[[383]]+pl[[384]]+pl[[385]]+pl[[386]]+pl[[387]]+pl[[388]]+pl[[389]]+pl[[390]]+pl[[391]]+pl[[392]]+pl[[393]]+pl[[394]]+pl[[395]]+pl[[396]]+pl[[397]]+pl[[398]]+pl[[399]]+pl[[400]]+
        ps    +xttl1    +xttl2    +xttl3    +xttl4    +xttl5    +xttl6    +xttl7    +xttl8    +xttl9    +xttl10   +xttl11   +xttl12   +xttl13   +xttl14   +xttl15   +xttl16   +xttl17   +xttl18   +xttl19   +xttl20   +
        plot_layout(widths = wds, heights = hts, guides = "collect")
}




 else if (length(xglns) == 3 & length(yglns) == 1) {
  plt = yttl1 +pl[[  1]]+pl[[  2]]+pl[[  3]]+pl[[  4]]+pl[[  5]]+pl[[  6]]+pl[[  7]]+pl[[  8]]+pl[[  9]]+pl[[ 10]]+pl[[ 11]]+pl[[ 12]]+pl[[ 13]]+pl[[ 14]]+pl[[ 15]]+pl[[ 16]]+pl[[ 17]]+pl[[ 18]]+pl[[ 19]]+pl[[ 20]]+
        yttl2 +pl[[ 21]]+pl[[ 22]]+pl[[ 23]]+pl[[ 24]]+pl[[ 25]]+pl[[ 26]]+pl[[ 27]]+pl[[ 28]]+pl[[ 29]]+pl[[ 30]]+pl[[ 31]]+pl[[ 32]]+pl[[ 33]]+pl[[ 34]]+pl[[ 35]]+pl[[ 36]]+pl[[ 37]]+pl[[ 38]]+pl[[ 39]]+pl[[ 40]]+
        yttl3 +pl[[ 41]]+pl[[ 42]]+pl[[ 43]]+pl[[ 44]]+pl[[ 45]]+pl[[ 46]]+pl[[ 47]]+pl[[ 48]]+pl[[ 49]]+pl[[ 50]]+pl[[ 51]]+pl[[ 52]]+pl[[ 53]]+pl[[ 54]]+pl[[ 55]]+pl[[ 56]]+pl[[ 57]]+pl[[ 58]]+pl[[ 59]]+pl[[ 60]]+
        yttl4 +pl[[ 61]]+pl[[ 62]]+pl[[ 63]]+pl[[ 64]]+pl[[ 65]]+pl[[ 66]]+pl[[ 67]]+pl[[ 68]]+pl[[ 69]]+pl[[ 70]]+pl[[ 71]]+pl[[ 72]]+pl[[ 73]]+pl[[ 74]]+pl[[ 75]]+pl[[ 76]]+pl[[ 77]]+pl[[ 78]]+pl[[ 79]]+pl[[ 80]]+
        yttl5 +pl[[ 81]]+pl[[ 82]]+pl[[ 83]]+pl[[ 84]]+pl[[ 85]]+pl[[ 86]]+pl[[ 87]]+pl[[ 88]]+pl[[ 89]]+pl[[ 90]]+pl[[ 91]]+pl[[ 92]]+pl[[ 93]]+pl[[ 94]]+pl[[ 95]]+pl[[ 96]]+pl[[ 97]]+pl[[ 98]]+pl[[ 99]]+pl[[100]]+
        yttl6 +pl[[101]]+pl[[102]]+pl[[103]]+pl[[104]]+pl[[105]]+pl[[106]]+pl[[107]]+pl[[108]]+pl[[109]]+pl[[110]]+pl[[111]]+pl[[112]]+pl[[113]]+pl[[114]]+pl[[115]]+pl[[116]]+pl[[117]]+pl[[118]]+pl[[119]]+pl[[120]]+
        yttl7 +pl[[121]]+pl[[122]]+pl[[123]]+pl[[124]]+pl[[125]]+pl[[126]]+pl[[127]]+pl[[128]]+pl[[129]]+pl[[130]]+pl[[131]]+pl[[132]]+pl[[133]]+pl[[134]]+pl[[135]]+pl[[136]]+pl[[137]]+pl[[138]]+pl[[139]]+pl[[140]]+
        yttl8 +pl[[141]]+pl[[142]]+pl[[143]]+pl[[144]]+pl[[145]]+pl[[146]]+pl[[147]]+pl[[148]]+pl[[149]]+pl[[150]]+pl[[151]]+pl[[152]]+pl[[153]]+pl[[154]]+pl[[155]]+pl[[156]]+pl[[157]]+pl[[158]]+pl[[159]]+pl[[160]]+
        yttl9 +pl[[161]]+pl[[162]]+pl[[163]]+pl[[164]]+pl[[165]]+pl[[166]]+pl[[167]]+pl[[168]]+pl[[169]]+pl[[170]]+pl[[171]]+pl[[172]]+pl[[173]]+pl[[174]]+pl[[175]]+pl[[176]]+pl[[177]]+pl[[178]]+pl[[179]]+pl[[180]]+
        yttl10+pl[[181]]+pl[[182]]+pl[[183]]+pl[[184]]+pl[[185]]+pl[[186]]+pl[[187]]+pl[[188]]+pl[[189]]+pl[[190]]+pl[[191]]+pl[[192]]+pl[[193]]+pl[[194]]+pl[[195]]+pl[[196]]+pl[[197]]+pl[[198]]+pl[[199]]+pl[[200]]+
        yttl11+pl[[201]]+pl[[202]]+pl[[203]]+pl[[204]]+pl[[205]]+pl[[206]]+pl[[207]]+pl[[208]]+pl[[209]]+pl[[210]]+pl[[211]]+pl[[212]]+pl[[213]]+pl[[214]]+pl[[215]]+pl[[216]]+pl[[217]]+pl[[218]]+pl[[219]]+pl[[220]]+
        yttl12+pl[[221]]+pl[[222]]+pl[[223]]+pl[[224]]+pl[[225]]+pl[[226]]+pl[[227]]+pl[[228]]+pl[[229]]+pl[[230]]+pl[[231]]+pl[[232]]+pl[[233]]+pl[[234]]+pl[[235]]+pl[[236]]+pl[[237]]+pl[[238]]+pl[[239]]+pl[[240]]+
        yttl13+pl[[241]]+pl[[242]]+pl[[243]]+pl[[244]]+pl[[245]]+pl[[246]]+pl[[247]]+pl[[248]]+pl[[249]]+pl[[250]]+pl[[251]]+pl[[252]]+pl[[253]]+pl[[254]]+pl[[255]]+pl[[256]]+pl[[257]]+pl[[258]]+pl[[259]]+pl[[260]]+
        yttl14+pl[[261]]+pl[[262]]+pl[[263]]+pl[[264]]+pl[[265]]+pl[[266]]+pl[[267]]+pl[[268]]+pl[[269]]+pl[[270]]+pl[[271]]+pl[[272]]+pl[[273]]+pl[[274]]+pl[[275]]+pl[[276]]+pl[[277]]+pl[[278]]+pl[[279]]+pl[[280]]+
        yttl15+pl[[281]]+pl[[282]]+pl[[283]]+pl[[284]]+pl[[285]]+pl[[286]]+pl[[287]]+pl[[288]]+pl[[289]]+pl[[290]]+pl[[291]]+pl[[292]]+pl[[293]]+pl[[294]]+pl[[295]]+pl[[296]]+pl[[297]]+pl[[298]]+pl[[299]]+pl[[300]]+
        yttl16+pl[[301]]+pl[[302]]+pl[[303]]+pl[[304]]+pl[[305]]+pl[[306]]+pl[[307]]+pl[[308]]+pl[[309]]+pl[[310]]+pl[[311]]+pl[[312]]+pl[[313]]+pl[[314]]+pl[[315]]+pl[[316]]+pl[[317]]+pl[[318]]+pl[[319]]+pl[[320]]+
        yttl17+pl[[321]]+pl[[322]]+pl[[323]]+pl[[324]]+pl[[325]]+pl[[326]]+pl[[327]]+pl[[328]]+pl[[329]]+pl[[330]]+pl[[331]]+pl[[332]]+pl[[333]]+pl[[334]]+pl[[335]]+pl[[336]]+pl[[337]]+pl[[338]]+pl[[339]]+pl[[340]]+
        yttl18+pl[[341]]+pl[[342]]+pl[[343]]+pl[[344]]+pl[[345]]+pl[[346]]+pl[[347]]+pl[[348]]+pl[[349]]+pl[[350]]+pl[[351]]+pl[[352]]+pl[[353]]+pl[[354]]+pl[[355]]+pl[[356]]+pl[[357]]+pl[[358]]+pl[[359]]+pl[[360]]+
        yttl19+pl[[361]]+pl[[362]]+pl[[363]]+pl[[364]]+pl[[365]]+pl[[366]]+pl[[367]]+pl[[368]]+pl[[369]]+pl[[370]]+pl[[371]]+pl[[372]]+pl[[373]]+pl[[374]]+pl[[375]]+pl[[376]]+pl[[377]]+pl[[378]]+pl[[379]]+pl[[380]]+
        yttl20+pl[[381]]+pl[[382]]+pl[[383]]+pl[[384]]+pl[[385]]+pl[[386]]+pl[[387]]+pl[[388]]+pl[[389]]+pl[[390]]+pl[[391]]+pl[[392]]+pl[[393]]+pl[[394]]+pl[[395]]+pl[[396]]+pl[[397]]+pl[[398]]+pl[[399]]+pl[[400]]+
        ps    +xttl1    +xttl2    +xttl3    +xttl4    +xttl5    +xttl6    +xttl7    +xttl8    +xttl9    +xttl10   +xttl11   +xttl12   +xttl13   +xttl14   +xttl15   +xttl16   +xttl17   +xttl18   +xttl19   +xttl20   +
        plot_layout(widths = wds, heights = hts, guides = "collect")
}


test_plot = pl[[ 1]] + pl[[ 2]] + pl[[ 3]] + pl[[ 4]] +
            pl[[ 5]] + pl[[ 6]] + pl[[ 7]] + pl[[ 8]] +
            pl[[ 9]] + pl[[10]] + pl[[11]] + pl[[12]] +
            pl[[13]] + pl[[14]] + pl[[15]] + pl[[16]] + plot_layout(widths = xglns, heights = yglns, guides = "collect")


pl + plot_layout(widths = xglns, heights = yglns, guides = "collect")

?patchwork::wrap_plots
```




```{r}
hhm = function(df,ylower,yupper,xlower,xupper,values,rm_diag=F,bins=15,cbrks=NULL) {
  
  # Remove unwanted rows and format origin so geographies appear in alphabetical order
  df = df[,c(ylower,xlower,yupper,xupper,values)]
  
  # If user specified to remove diagonal values, set all observations where ylower and xlower are identical to zero
  if (rm_diag) {
    df[df[[ylower]] == df[[xlower]],values] = 0
  }

  # Define names of custom breaks
  brk_nms = c(0, paste(cbrks %>% .[1:(length(.)-1)] %>% sprintf(fmt = paste0('%#.3f')), 
                       cbrks %>% .[2: length(.)   ] %>% sprintf(fmt = paste0('%#.3f')), sep = "-"))
  
  # Create discrete scale based on these custom breaks
  df[["scaled"]] = df[[paste0(var,"_scld")]] %>% findInterval(cbrks) %>% ifelse(df[[paste0(var,"_scld")]] == 0, 0, .) %>% 
                   replace(. == length(cbrks), (length(cbrks)-1)) %>% {. + 1} %>% factor(levels = 1:bns, labels = brk_nms)
  
  # Create empty list to populate with ggplot heatmaps
  pl = list()
  
  # Counter to keep track of interations of nested for loop
  i = 0
  
  # For each origin region
  for (og in 1:length(rgns)) {
    
    # For each destination region
    for (dn in 1:length(rgns)) {
      
      # Increase interature counter by 1
      i = i + 1
      
      # Filter provincia-level migration data to only include origin and destination regions of interest
      sdf = df %>% filter(ogr == rgns[og] & dnr == rgns[dn]) %>%
                   mutate(Origin = factor(Origin, levels = Origin %>% unique() %>% rev() ))
      
      # Define main plot
      p = ggplot(sdf, aes(Destination, Origin)) +
        geom_tile(aes(fill = scaled), show.legend = T) +
        scale_fill_manual(name = "Normalised\nCount", values = cg("white","#08306B",bns), drop = F) +
        theme(plot.margin = unit(rep(0,4), "cm"),
              axis.text.x  = element_text(angle = 90, hjust = 1.0, vjust = 0.3),
              axis.title.x = element_text(angle = 90, hjust = 0.5, vjust = 0.5),
              axis.title.y = element_text(angle =  0, hjust = 0.5, vjust = 0.5),
              axis.ticks   = element_blank()) +
        labs(x = rgns[dn], y = rgns[og])
      
      # If bottom-left plot
      if (og == length(rgns) & dn == 1) {
        # Include provincia names on both axes
        p = p + theme(axis.title.x = element_blank(),
                      axis.title.y = element_blank())
      } else if (og < length(rgns) & dn == 1) { # If left-hand plot
        # Include provincia names on y-axis
        p = p + theme(axis.title.x = element_blank(),
                      axis.title.y = element_blank(),
                      axis.text.x  = element_blank())
      } else if (og == length(rgns) & dn > 1) { # If bottom plot
        # Include provincia names on x-axis
        p = p + theme(axis.title.x = element_blank(),
                      axis.title.y = element_blank(),
                      axis.text.y  = element_blank())
      } else { # If plot not on left of bottom edges of multiplot
        # Remove provincia names
        p = p + theme(axis.title.x = element_blank(),
                      axis.title.y = element_blank(),
                      axis.text.x  = element_blank(),
                      axis.text.y  = element_blank())
      }
      
      # Add ggplot to plot list
      pl[[i]] = p
      
    }
    
  }
  
  # Return list of plots
  return(pl)
}
```





# Define functions and key inputs to make provincia heatmaps
```{r,fig.width=20}
# Function that creates a logged sequence to use in ggplot legend scale
log_seq = function(n,ln=15) {
  
  # Create a sequence from 1 to n
  seq = seq(1, n, length.out = ln-1)
  
  # Apply the logarithm to the sequence
  log_seq = log(seq)
  
  # Scale the sequence to the range [0, 1]
  min_val = min(log_seq)
  max_val = max(log_seq)
  one_seq = ((log_seq - min_val) / (max_val - min_val))
  
  # Reverse pattern of scale so breaks are focussed on lower rather than upper end of scale
  one_seq_rev = one_seq %>% {. - max(.)} %>% {. * -1} %>% rev()
  
  # Scale sequence to n
  scaled_one_seq = one_seq_rev %>% {. * n} %>% round() %>% {. + 1} %>% c(0,.)
  
  return(scaled_one_seq)
}

# Function that creates colour gradient between two hexcodes
cg <- function(colour1, colour2, n = 15) {
  
  # Create a color palette function
  colour_func <- grDevices::colorRampPalette(c(colour1, colour2))
  
  # Generate the color gradient
  colour_gradient <- colour_func(n)
  
  # Return colour gradient
  return(colour_gradient)
}

# Function that creates blank plot with only text of region
# Used to plot region names in the final heatmap multiplot
plt_ttl = function(ttl,axs="x") {
  
  # If plotting on x-axis
  if (axs == "x") {
    
    # Place at top of plot and rotate 90 degrees
    p = ggplot(data.frame(x = 0:1, y = 0:1), aes(x = x, y = y)) + 
      geom_point(col = "white") + 
      geom_text(x = 0.495, y = 1, angle = 90, label = ttl, size = 4, hjust = 1) + 
      coord_cartesian(xlim = c(0,1), ylim = c(0,1)) +
      theme_void() +
      theme(plot.margin = unit(rep(0,4), "cm"))
    
  } else if (axs == "y") { # If plotting on y-axis
    
    # Place at left of plot
    p = ggplot(data.frame(x = 0:1, y = 0:1), aes(x = x, y = y)) + 
      geom_point(col = "white") + 
      geom_text(x = 1, y = 0.51, angle =  0, label = ttl, size = 4, hjust = 1) + 
      coord_cartesian(xlim = c(0,1), ylim = c(0,1)) +
      theme_void() +
      theme(plot.margin = unit(rep(0,4), "cm"))

  }
  
  # Return region name plot
  return(p)
}

# Function that plots provincia-level heatmap grouped by region
pr_htmp = function(df,var,bns=15) {
  
  # Remove unwanted rows and format origin so geographies appear in alphabetical order
  df = df[,c("Origin","Destination","ogr","dnr",var)]
  df[,paste0(var,"_scld")] = df[[var]] / max(df[[var]])
  
  # Create lookup table of all origin and destination provincias
  od_lkp = expand.grid(Origin = lkp[["provincia"]], Destination = lkp[["provincia"]]) %>% full_join(lkp_og) %>% full_join(lkp_dn)
  
  # Add values for diagonals, so they can be assigned 0 (causes them to show up as white squares in the final plot)
  df = df %>% full_join(od_lkp) %>% arrange(Origin,Destination,ogr,dnr)
  
  # Assign diagonal as zero
  df[df$Origin == df$Destination,paste0(var,"_scld")] = 0
  
  # Create custom breaks for log scale
  cbrks = log_seq(999,bns) / 1000

  # Define names of custom breaks
  brk_nms = c(0, paste(cbrks %>% .[1:(length(.)-1)] %>% sprintf(fmt = paste0('%#.3f')), 
                       cbrks %>% .[2: length(.)   ] %>% sprintf(fmt = paste0('%#.3f')), sep = "-"))
  
  # Create discrete scale based on these custom breaks
  df[["scaled"]] = df[[paste0(var,"_scld")]] %>% findInterval(cbrks) %>% ifelse(df[[paste0(var,"_scld")]] == 0, 0, .) %>% 
                   replace(. == length(cbrks), (length(cbrks)-1)) %>% {. + 1} %>% factor(levels = 1:bns, labels = brk_nms)
  
  # Create empty list to populate with ggplot heatmaps
  pl = list()
  
  # Counter to keep track of interations of nested for loop
  i = 0
  
  # For each origin region
  for (og in 1:length(rgns)) {
    
    # For each destination region
    for (dn in 1:length(rgns)) {
      
      # Increase interature counter by 1
      i = i + 1
      
      # Filter provincia-level migration data to only include origin and destination regions of interest
      sdf = df %>% filter(ogr == rgns[og] & dnr == rgns[dn]) %>%
                   mutate(Origin = factor(Origin, levels = Origin %>% unique() %>% rev() ))
      
      # Define main plot
      p = ggplot(sdf, aes(Destination, Origin)) +
        geom_tile(aes(fill = scaled), show.legend = T) +
        scale_fill_manual(name = "Normalised\nCount", values = cg("white","#08306B",bns), drop = F) +
        theme(plot.margin = unit(rep(0,4), "cm"),
              axis.text.x  = element_text(angle = 90, hjust = 1.0, vjust = 0.3),
              axis.title.x = element_text(angle = 90, hjust = 0.5, vjust = 0.5),
              axis.title.y = element_text(angle =  0, hjust = 0.5, vjust = 0.5),
              axis.ticks   = element_blank()) +
        labs(x = rgns[dn], y = rgns[og])
      
      # If bottom-left plot
      if (og == length(rgns) & dn == 1) {
        # Include provincia names on both axes
        p = p + theme(axis.title.x = element_blank(),
                      axis.title.y = element_blank())
      } else if (og < length(rgns) & dn == 1) { # If left-hand plot
        # Include provincia names on y-axis
        p = p + theme(axis.title.x = element_blank(),
                      axis.title.y = element_blank(),
                      axis.text.x  = element_blank())
      } else if (og == length(rgns) & dn > 1) { # If bottom plot
        # Include provincia names on x-axis
        p = p + theme(axis.title.x = element_blank(),
                      axis.title.y = element_blank(),
                      axis.text.y  = element_blank())
      } else { # If plot not on left of bottom edges of multiplot
        # Remove provincia names
        p = p + theme(axis.title.x = element_blank(),
                      axis.title.y = element_blank(),
                      axis.text.x  = element_blank(),
                      axis.text.y  = element_blank())
      }
      
      # Add ggplot to plot list
      pl[[i]] = p
      
    }
    
  }
  
  # Return list of plots
  return(pl)
}

# Define region names
rgns = c(provincia$ogr,provincia$dnr) %>% unique() %>% sort()

# Define widths of multiplots
pws = lkp %>% group_by(region) %>% summarise(n = n()) %>% .$n

# Create empty lists to populate with region names
ot = list()
dt = list()

# For loop that creates ggplots containing only region names
for (i in 1:length(rgns)) {
  ot[[i]] = plt_ttl(rgns[i], axs = "y") 
  dt[[i]] = plt_ttl(rgns[i], axs = "x") 
}
```



















# Colour schemes
```{r}
brewer.pal(n = 9, name = 'Greys')
```

```{r, fig.height=4}
display.brewer.pal(n = 9, name = 'Greys')
```

```{r, fig.height=9}
display.brewer.all(colorblindFriendly = T)
```
