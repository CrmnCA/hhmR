}
# Create discrete scale based on these custom breaks
df[[values]] = df[[values]] %>% findInterval(cbrks) %>% {. + 1} %>% addNA() %>%
factor(levels = 1:length(brk_nms), labels = brk_nms)
} else if (!is.null(bins)) { # If bins provided
# Assign breaks to be equidistant thresholds between the minimum and maximum observed values
# Also add the minimum possible value above zero as the first break in the sequence
cbrks = seq(min(df[[values]], na.rm = T), max(df[[values]], na.rm = T), length.out = bins - 1) %>% .[1:(length(.)-1)] %>% c(.Machine$double.xmin,.)
# Define names of custom breaks
if (lgdps == 0) { # If set to show whole numbers
# Round all values other than the first one (which is the minimum possible value above zero), up to the nearest whole number
cbrks = c(.Machine$double.xmin, cbrks %>% .[2:length(.)] %>% ceiling())
# Assign break names between zero and the maximum observed value in the data
brk_nms = c(0, paste(cbrks %>% .[2:length(.)] %>% c(0,.        ),
cbrks %>% .[2:length(.)] %>% c(.,max_value),
sep = "-"))
} else if (norm_lgd) { # If data has been normalised
# Assign break names between 0 and 1 to the specified number of decimal points (lgdps)
brk_nms = c(0, paste(cbrks %>% .[2:length(.)] %>% c(0,.        ) %>% sprintf(fmt = paste0('%#.',lgdps,'f')),
cbrks %>% .[2:length(.)] %>% c(.,1        ) %>% sprintf(fmt = paste0('%#.',lgdps,'f')),
sep = "-"))
} else { # If using non-rounded, non-normalised data
# Assign break names between zero and the maximum observed value in the data to the specified number of decimal points (lgdps)
brk_nms = c(0, paste(cbrks %>% .[2:length(.)] %>% c(0,.        ) %>% sprintf(fmt = paste0('%#.',lgdps,'f')),
cbrks %>% .[2:length(.)] %>% c(.,max_value) %>% sprintf(fmt = paste0('%#.',lgdps,'f')),
sep = "-"))
}
# Create discrete scale based on these custom breaks
df[[values]] = df[[values]] %>% findInterval(cbrks) %>%
replace(. == length(cbrks), (length(cbrks)-.Machine$double.xmin)) %>%
{. + 1} %>% addNA() %>%
factor(levels = 1:length(brk_nms), labels = brk_nms)
} else { # Otherwise define consistent legend scale range
lg_lims = df[[values]] %>% range(na.rm = T)
}
# Define legend title (if not defined by user)
if (is.null(lgttl) && norm_lgd) {
lgttl = "Normalised\nValues"
} else if (is.null(lgttl) && norm_lgd == F) {
lgttl = "Values"
}
# Create empty list to populate with ggplot heatmaps
pl = list()
# Define vectors capturing the number of lower categories in each upper group
xglns = df %>% group_split(!!rlang::sym(xupper)) %>% map(~ .[[xlower]] %>% unique() %>% length()) %>% unlist()
yglns = df %>% group_split(!!rlang::sym(yupper)) %>% map(~ .[[ylower]] %>% unique() %>% length()) %>% unlist()
# Counter to keep track of interations of nested for loop
i = 0
# For each y-axis group
for (ygrp in 1:length(ygrps)) {
# For each x-axis group
for (xgrp in 1:length(xgrps)) {
# Increase interature counter by 1
i = i + 1
# Filter group-level migration data to only include origin and destination regions of interest
sdf = df[df[[yupper]] == ygrps[ygrp] & df[[xupper]] == xgrps[xgrp],]
# Order lower categories alphabetically
sdf[[xlower]] = factor(sdf[[xlower]], levels = sdf[[xlower]] %>% unique() %>% sort()           )
sdf[[ylower]] = factor(sdf[[ylower]], levels = sdf[[ylower]] %>% unique() %>% sort() %>% rev() )
# Define main plot
p = ggplot(sdf, aes(.data[[xlower]], .data[[ylower]])) +
geom_tile(aes(fill = .data[[values]]), show.legend = T) +
theme(plot.margin = unit(rep(0,4), "cm"),
axis.text.x  = element_text(angle = 90, hjust = 1.0, vjust = 0.3),
axis.title.x = element_text(angle = 90, hjust = 0.5, vjust = 0.5),
axis.title.y = element_text(angle =  0, hjust = 0.5, vjust = 0.5),
axis.ticks   = element_blank()) +
labs(x = xgrps[xgrp], y = ygrps[ygrp])
# Define colour scale
if (!is.null(cbrks) && !is.null(cclrs)) {
p = p + scale_fill_manual(name = lgttl, values = cclrs                                  , drop = F, na.value = "white")
} else if (!is.null(cbrks) && is.null(cclrs)) {
p = p + scale_fill_manual(name = lgttl, values = cg("white","#08306B",(length(cbrks)+1)), drop = F, na.value = "white")
} else if (is.null(cbrks) && !is.null(cclrs) && norm_lgd) {
p = p + scale_fill_gradientn(name = lgttl, colours = cclrs                , limits = c(0,1) , na.value = "white")
} else if (is.null(cbrks) && !is.null(cclrs) && norm_lgd == F) {
p = p + scale_fill_gradientn(name = lgttl, colours = cclrs                , limits = lg_lims, na.value = "white")
} else if (is.null(cbrks) && is.null(cclrs) && norm_lgd) {
p = p + scale_fill_gradientn(name = lgttl, colours = cg("white","#08306B"), limits = c(0,1) , na.value = "white")
} else if (is.null(cbrks) && is.null(cclrs) && norm_lgd == F) {
p = p + scale_fill_gradientn(name = lgttl, colours = cg("white","#08306B"), limits = lg_lims, na.value = "white")
}
# To prevent legend showing NA values if rm_diag set to TRUE (in which case, diagonal set to NA), only show legend for plots that are not on the diagonal
if (rm_diag && (sdf[[values]] %>% is.na() %>% sum() %>% {. > 0}) && (ygrp == xgrp) ) {
p = p + theme(legend.position = "none")
}
# If bottom-left plot
if (ygrp == length(ygrps) & xgrp == 1) {
# Include provincia names on both axes
p = p + theme(axis.title.x = element_blank(),
axis.title.y = element_blank())
} else if (ygrp < length(ygrps) & xgrp == 1) { # If left-hand plot
# Include provincia names on y-axis
p = p + theme(axis.title.x = element_blank(),
axis.title.y = element_blank(),
axis.text.x  = element_blank())
} else if (ygrp == length(ygrps) & xgrp > 1) { # If bottom plot
# Include provincia names on x-axis
p = p + theme(axis.title.x = element_blank(),
axis.title.y = element_blank(),
axis.text.y  = element_blank())
} else { # If plot not on left of bottom edges of multiplot
# Remove provincia names
p = p + theme(axis.title.x = element_blank(),
axis.title.y = element_blank(),
axis.text.x  = element_blank(),
axis.text.y  = element_blank())
}
# Add ggplot to plot list
pl[[i]] = p
}
}
# Define plot heights and widths (including group titles)
wds = c((sum(xglns)*yttl_width),xglns)
hts = c(yglns,(sum(yglns)*xttl_height))
# Define plot spacer
ps = plot_spacer()
# Create empty lists to be populated with plot titles
xttls = list()
yttls = list()
# Define plot titles
for (xgrp in 1:length(xgrps)) {
xttls[[xgrp]] = plt_ttl(xgrps[xgrp])
}
for (ygrp in 1:length(ygrps)) {
yttls[[ygrp]] = plt_ttl(ygrps[ygrp],axs="y")
}
# Create empty list to populate with both plot title and heatmap tiles in the correct order
plts = list()
# Define counters for subsetting plot title and heatmap lists, to ensure they are ordered correctly
i = 1
j = 1
# For each group (row), assign each plot title, then the heatmap tiles within that row to plts list
for (ygrp in 1:length(yttls)) {
# Add plot title to list
plts[[i]] = yttls[[ygrp]]
# Add heatmap plots to list
plts[(i+1):(i+length(xttls))] = pl[j:(j+length(xttls)-1)]
# Adjust counters
i = i + 1 + length(xttls)
j = j +     length(xttls)
}
# Add x-axis plots
plts[[length(plts)+1]] = ps
plts[(length(plts)+1):(length(plts)+length(xttls))] = xttls
# Define final plot
plt = patchwork::wrap_plots(plts, widths = wds, heights = hts, guides = "collect")
# Return final plot
return(plt)
}
# IMPORT PACKAGES
#library(hhmR)
# CREATE TOY DATA OF INTERNAL MIGRATION BETWEEN COUNTIES (LOWER LEVEL) AND REGIONS (UPPER LEVEL)
## Define names of fake counties
#fake_counties = c("Greenridge","Windermoor","Bramblewood","Silverlake","Thornbury","Maplewood",
#                  "Hawthorne","Pinehurst","Riverton","Meadowbrook","Fairhaven","Oakdale","Stonebridge",
#                  "Brookfield","Ashford","Glenville","Sunnyvale","Westfield")
#
## Create region county lookup tables
#rc_lkp = data.frame(region = c(rep("North",3),rep("Midlands",5),rep("South West",4),rep("South East",6)), county = fake_counties)
#og_lkp = rc_lkp %>% setNames(c("Origin Region"     ,"Origin County"     ))
#dn_lkp = rc_lkp %>% setNames(c("Destination Region","Destination County"))
#
## Create dataframe of fake migration data
#set.seed(1234)
#od_df = expand.grid(fake_counties,fake_counties) %>% setNames(paste(c("Origin","Destination"),"County",sep=" ")) %>% full_join(og_lkp) %>% full_join(dn_lkp) %>%
#        mutate(Migration = (1/rgamma(18*18, shape = 17, rate = 0.5)) %>% {. * 1000} %>% round())
#od_df[od_df$`Origin County` == od_df$`Destination County`,"Migration"] = od_df[od_df$`Origin County` == od_df$`Destination County`,"Migration"] * 10
# Define names of fake counties
fake_counties = c("Greenridge","Windermoor","Bramblewood","Silverlake",
"Thornbury","Maplewood","Hawthorne","Pinehurst",
"Riverton","Meadowbrook","Fairhaven","Oakdale","Stonebridge",
"Brookfield","Ashford","Glenville","Sunnyvale","Westfield")
# Create region county lookup tables
rc_lkp = data.frame(region = c(rep("North",3),rep("Midlands",5),
rep("South West",4),rep("South East",6)),
county = fake_counties)
og_lkp = rc_lkp %>% setNames(c("Origin Region"     ,"Origin County"     ))
dn_lkp = rc_lkp %>% setNames(c("Destination Region","Destination County"))
# Create dataframe of fake migration data
set.seed(1234)
example_migration = expand.grid(fake_counties,fake_counties) %>%
setNames(paste(c("Origin","Destination"),"County",sep=" ")) %>%
full_join(og_lkp) %>% full_join(dn_lkp)
example_migration$Migration = (1/rgamma(18*18, shape = 17, rate = 0.5)) %>%
{. * 1000} %>% round()
example_migration[example_migration$`Origin County` ==
example_migration$`Destination County`,"Migration"] =
example_migration[example_migration$`Origin County` ==
example_migration$`Destination County`,"Migration"] * 10
# RUN FUNCTION
# Intial heatmap
hierarchical_heatmap = hhm(df = example_migration,
ylower = "Origin County",
xlower = "Destination County",
yupper = "Origin Region",
xupper = "Destination Region",
values = "Migration",
yttl_width = 0.22,
xttl_height = 0.4)
# View result
hierarchical_heatmap
# Remove diagonal from heatmap (i.e. hide static populations)
removed_diag         = hhm(df = example_migration,
ylower = "Origin County",
xlower = "Destination County",
yupper = "Origin Region",
xupper = "Destination Region",
values = "Migration",
yttl_width = 0.22,
xttl_height = 0.4,
rm_diag = T)
# Vuew result
removed_diag
# Nomalise the legend
normalised_lgd       = hhm(df = example_migration,
ylower = "Origin County",
xlower = "Destination County",
yupper = "Origin Region",
xupper = "Destination Region",
values = "Migration",
yttl_width = 0.22,
xttl_height = 0.4,
rm_diag = T,
norm_lgd = T)
# View result
normalised_lgd
# Manually define colour scheme for heatmap (uses viridis colour scheme)
viridis_12 = c("#440154FF","#482173FF","#433E85FF","#38598CFF","#2D708EFF","#25858EFF","#1E9B8AFF","#2BB07FFF","#51C56AFF","#85D54AFF","#C2DF23FF","#FDE725FF")
# Assign continuous colour scheme
cont_clrs            = hhm(df = example_migration,
ylower = "Origin County",
xlower = "Destination County",
yupper = "Origin Region",
xupper = "Destination Region",
values = "Migration",
yttl_width = 0.22,
xttl_height = 0.4,
rm_diag = T,
norm_lgd = T,
cclrs = viridis_12)
# View result
cont_clrs
# Break legends into a specified number of bins (of equal intervals between 0 and the maximum value in `values`)
bins_15              = hhm(df = example_migration,
ylower = "Origin County",
xlower = "Destination County",
yupper = "Origin Region",
xupper = "Destination Region",
values = "Migration",
yttl_width = 0.22,
xttl_height = 0.4,
rm_diag = T,
bins = 15)
# View result
bins_15
# Create breaks to view data using a categoric scale.
# In this instance, the `hhmR` function `log_seq` has been used to create a vector of logarithmicly increasing values between 1 and
# the maximum value in the dataset not on the diagonal.
cbrks = log_seq(example_migration %>% filter(`Origin County` != `Destination County`) %>% .$Migration %>% max(), 12, rmv_extremes = T)
# Manually assign legend categories
legend_cats          = hhm(df = example_migration,
ylower = "Origin County",
xlower = "Destination County",
yupper = "Origin Region",
xupper = "Destination Region",
values = "Migration",
yttl_width = 0.22,
xttl_height = 0.4,
rm_diag = T,
cbrks = cbrks)
# View result
legend_cats
# Manually assign colours to legend categories
cat_clrs             = hhm(df = example_migration,
ylower = "Origin County",
xlower = "Destination County",
yupper = "Origin Region",
xupper = "Destination Region",
values = "Migration",
yttl_width = 0.22,
xttl_height = 0.4,
rm_diag = T,
cbrks = cbrks,
cclrs = viridis_12)
# View result
cat_clrs
# Break normalised data into bins
norm_bins            = hhm(df = example_migration,
ylower = "Origin County",
xlower = "Destination County",
yupper = "Origin Region",
xupper = "Destination Region",
values = "Migration",
rm_diag = T,
lgttl=NULL,
bins=15,
cbrks=NULL,
cclrs=NULL,
norm_lgd=T,
lgdps=0,
yttl_width = 0.22,
xttl_height = 0.4)
# View results
norm_bins
# Assigned custom colour scheme to normalised, binned data
norm_bins_clrs       = hhm(df = example_migration,
ylower = "Origin County",
xlower = "Destination County",
yupper = "Origin Region",
xupper = "Destination Region",
values = "Migration",
rm_diag = T,
lgttl=NULL,
bins=12,
cbrks=NULL,
cclrs=viridis_12,
norm_lgd=T,
lgdps=0,
yttl_width = 0.22,
xttl_height = 0.4)
# View results
norm_bins_clrs
# Create breaks to view normalised data using a categoric scale.
# In this instance, the `hhmR` function `log_seq` has been used to create a vector of logarithmicly increasing values between 0 and 1.
cbrks = seq(0,1,length.out=12) %>% .[2:(length(.)-1)]
# Manually assign legend categories
norm_legend_cats     = hhm(df = example_migration,
ylower = "Origin County",
xlower = "Destination County",
yupper = "Origin Region",
xupper = "Destination Region",
values = "Migration",
yttl_width = 0.22,
xttl_height = 0.4,
rm_diag = T,
cbrks = cbrks,
norm_lgd = T)
# View result
norm_legend_cats
# Manually add colour scheme
norm_legend_cats_cls = hhm(df = example_migration,
ylower = "Origin County",
xlower = "Destination County",
yupper = "Origin Region",
xupper = "Destination Region",
values = "Migration",
yttl_width = 0.22,
xttl_height = 0.4,
rm_diag = T,
cbrks = cbrks,
cclrs = viridis_12,
norm_lgd = T)
# View result
norm_legend_cats_cls
# Nomalise the legend (but with diagonal)
normalised_lgd_wd    = hhm(df = example_migration,
ylower = "Origin County",
xlower = "Destination County",
yupper = "Origin Region",
xupper = "Destination Region",
values = "Migration",
yttl_width = 0.22,
xttl_height = 0.4,
norm_lgd = T)
# View result
normalised_lgd_wd
# Assign continuous colour scheme (but with diagonal)
cont_clrs_wd         = hhm(df = example_migration,
ylower = "Origin County",
xlower = "Destination County",
yupper = "Origin Region",
xupper = "Destination Region",
values = "Migration",
yttl_width = 0.22,
xttl_height = 0.4,
norm_lgd = T,
cclrs = viridis_12)
# View result
cont_clrs_wd
# Break legends into a specified number of bins (of equal intervals between 0 and the maximum value in `values`) (but with diagonal)
bins_15_wd           = hhm(df = example_migration,
ylower = "Origin County",
xlower = "Destination County",
yupper = "Origin Region",
xupper = "Destination Region",
values = "Migration",
yttl_width = 0.22,
xttl_height = 0.4,
bins = 15)
# View result
bins_15_wd
# Create breaks to view data using a categoric scale.
# In this instance, the `hhmR` function `log_seq` has been used to create a vector of logarithmicly increasing values between 1 and
# the maximum value in the dataset not on the diagonal.
cbrks = log_seq(example_migration %>% filter(`Origin County` != `Destination County`) %>% .$Migration %>% max(), 12, rmv_extremes = T)
# Manually assign legend categories (but with diagonal)
legend_cats_wd       = hhm(df = example_migration,
ylower = "Origin County",
xlower = "Destination County",
yupper = "Origin Region",
xupper = "Destination Region",
values = "Migration",
yttl_width = 0.22,
xttl_height = 0.4,
cbrks = cbrks)
# View result
legend_cats_wd
# Manually assign colours to legend categories (but with diagonal)
cat_clrs_wd          = hhm(df = example_migration,
ylower = "Origin County",
xlower = "Destination County",
yupper = "Origin Region",
xupper = "Destination Region",
values = "Migration",
yttl_width = 0.22,
xttl_height = 0.4,
cbrks = cbrks,
cclrs = viridis_12)
# View result
cat_clrs_wd
# Break normalised data into bins (but with diagonal)
norm_bins_wd         = hhm(df = example_migration,
ylower = "Origin County",
xlower = "Destination County",
yupper = "Origin Region",
xupper = "Destination Region",
values = "Migration",
lgttl=NULL,
bins=15,
cbrks=NULL,
cclrs=NULL,
norm_lgd=T,
lgdps=0,
yttl_width = 0.22,
xttl_height = 0.4)
# View results
norm_bins_wd
# Assigned custom colour scheme to normalised, binned data (but with diagonal)
norm_bins_clrs_wd    = hhm(df = example_migration,
ylower = "Origin County",
xlower = "Destination County",
yupper = "Origin Region",
xupper = "Destination Region",
values = "Migration",
lgttl=NULL,
bins=12,
cbrks=NULL,
cclrs=viridis_12,
norm_lgd=T,
lgdps=0,
yttl_width = 0.22,
xttl_height = 0.4)
# View results
norm_bins_clrs_wd
# Create breaks to view normalised data using a categoric scale.
# In this instance, the `hhmR` function `log_seq` has been used to create a vector of logarithmicly increasing values between 0 and 1.
cbrks = seq(0,1,length.out=12) %>% .[2:(length(.)-1)]
# Manually assign legend categories (but with diagonal)
norm_legend_cats_wd  = hhm(df = example_migration,
ylower = "Origin County",
xlower = "Destination County",
yupper = "Origin Region",
xupper = "Destination Region",
values = "Migration",
yttl_width = 0.22,
xttl_height = 0.4,
cbrks = cbrks,
norm_lgd = T)
# View result
norm_legend_cats_wd
# Manually add colour scheme (but with diagonal)
nrm_lgnd_cats_cls_wd = hhm(df = example_migration,
ylower = "Origin County",
xlower = "Destination County",
yupper = "Origin Region",
xupper = "Destination Region",
values = "Migration",
yttl_width = 0.22,
xttl_height = 0.4,
cbrks = cbrks,
cclrs = viridis_12,
norm_lgd = T)
# View result
nrm_lgnd_cats_cls_wd
# Manually add colour scheme (but with diagonal)
nrm_lgnd_cats_cls_wd = hhm(df = example_migration,
ylower = "Origin County",
xlower = "Destination County",
yupper = "Origin Region",
xupper = "Destination Region",
values = "Migration",
yttl_width = 0.22,
xttl_height = 0.4,
cbrks = cbrks,
cclrs = viridis_12,
norm_lgd = T)
# View result
nrm_lgnd_cats_cls_wd
devtool::document()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
?full_join
?mutate
devtools::document()
devtools::check()
devtools::document()
devtools::check()
?data
?.data
