legend_cats          = hhm(df = od_df,
ylower = "Origin County",
xlower = "Destination County",
yupper = "Origin Region",
xupper = "Destination Region",
values = "Migration",
yttl_width = 0.22,
xttl_height = 0.4,
rm_diag = T,
cbrks = cbrks)
# Vuew result
legend_cats
# Manually assign legend categories
cat_clrs             = hhm(df = od_df,
ylower = "Origin County",
xlower = "Destination County",
yupper = "Origin Region",
xupper = "Destination Region",
values = "Migration",
yttl_width = 0.22,
xttl_height = 0.4,
rm_diag = T,
cbrks = cbrks,
cclrs = viridis_10)
viridis(12)
# Manually define colour scheme for heatmap (uses viridis colour scheme)
viridis_12 = c("#440154FF","#482173FF","#433E85FF","#38598CFF","#2D708EFF","#25858EFF","#1E9B8AFF","#2BB07FFF","#51C56AFF","#85D54AFF","#C2DF23FF","#FDE725FF")
hhm(df = od_df,
ylower = "Origin County",
xlower = "Destination County",
yupper = "Origin Region",
xupper = "Destination Region",
values = "Migration",
yttl_width = 0.22,
xttl_height = 0.4,
rm_diag = T,
cbrks = cbrks,
cclrs = viridis_12)
od_df %>% filter(`Origin County` != `Destination County`) %>% .$Migration %>% max()
log_seq(od_df %>% filter(`Origin County` != `Destination County`) %>% .$Migration %>% max(), 10)
# Create breaks to view data using a categoric scale.
# In this instance, the `hhmR` function `log_seq` has been used to create a vector of logarithmicly increasing values between 1 and
# the maximum value in the dataset not on the diagonal.
cbrks = log_seq(od_df %>% filter(`Origin County` != `Destination County`) %>% .$Migration %>% max(), 10)
hhm(df = od_df,
ylower = "Origin County",
xlower = "Destination County",
yupper = "Origin Region",
xupper = "Destination Region",
values = "Migration",
yttl_width = 0.22,
xttl_height = 0.4,
rm_diag = T,
cbrks = cbrks)
log_seq(od_df %>% filter(`Origin County` != `Destination County`) %>% .$Migration %>% max(), 10)
#'
#' @examples
#' # Create sequence of length 20, scaled between 1 and 500
#' log_seq(500,20)
#'
#' # Create sequence of length 15, scaled between 0 and 1
#' log_seq(1,12)
#'
#' @export
#' @importFrom dplyr "%>%"
log_seq = function(n,ln=15,round_values=T,rmv_extremes=F) {
# Create a sequence from 1 to n.
# If `n` is specified as 1, the vector will be scaled to between 0 and 1.
if (n == 1) {
seq = seq(1, 1000, length.out = ln-1)
round_values = F
} else {
seq = seq(1, n, length.out = ln-2)
}
# Apply the logarithm to the sequence
log_seq = log(seq)
# Scale the sequence to the range [0, 1]
min_val = min(log_seq)
max_val = max(log_seq)
one_seq = ((log_seq - min_val) / (max_val - min_val))
# Reverse pattern of scale so breaks are focussed on lower rather than upper end of scale
one_seq_rev = one_seq %>% {. - max(.)} %>% {. * -1} %>% rev()
# Scale sequence to n
if (round_values) {
scaled_one_seq = one_seq_rev %>% {. * n} %>% round() %>% .[2:length(.)] %>% c(0,1,.)
} else if (n != 1) {
scaled_one_seq = one_seq_rev %>% {. * n} %>% .[2:length(.)] %>% c(0,.Machine$double.xmin,.)
} else {
scaled_one_seq = one_seq_rev
}
# Option to remove zero and the maximum value (i.e. `n`) from the beginning and the end of the vector
if (rmv_extremes) {
scaled_one_seq = scaled_one_seq %>% .[2:(length(.)-1)]
}
# Return scaled sequence
return(scaled_one_seq)
}
# Create breaks to view data using a categoric scale.
# In this instance, the `hhmR` function `log_seq` has been used to create a vector of logarithmicly increasing values between 1 and
# the maximum value in the dataset not on the diagonal.
cbrks = log_seq(od_df %>% filter(`Origin County` != `Destination County`) %>% .$Migration %>% max(), 10, rmv_extremes = T)
cbrks
# Create breaks to view data using a categoric scale.
# In this instance, the `hhmR` function `log_seq` has been used to create a vector of logarithmicly increasing values between 1 and
# the maximum value in the dataset not on the diagonal.
cbrks = log_seq(od_df %>% filter(`Origin County` != `Destination County`) %>% .$Migration %>% max(), 12, rmv_extremes = T)
cbrks
hhm(df = od_df,
ylower = "Origin County",
xlower = "Destination County",
yupper = "Origin Region",
xupper = "Destination Region",
values = "Migration",
yttl_width = 0.22,
xttl_height = 0.4,
rm_diag = T,
cbrks = cbrks)
hhm(df = od_df,
ylower = "Origin County",
xlower = "Destination County",
yupper = "Origin Region",
xupper = "Destination Region",
values = "Migration",
yttl_width = 0.22,
xttl_height = 0.4,
rm_diag = T,
cbrks = cbrks,
cclrs = viridis_12)
cbrks
log_seq(od_df %>% filter(`Origin County` != `Destination County`) %>% .$Migration %>% max(), 12, rmv_extremes = F)
n = 68
ln=15
round_values=T
rmv_extremes=F
n == 1
seq(1, n, length.out = ln)
n = 68
ln=12
round_values=T
rmv_extremes=F
seq = seq(1, n, length.out = ln)
# Apply the logarithm to the sequence
log_seq = log(seq)
# Scale the sequence to the range [0, 1]
min_val = min(log_seq)
max_val = max(log_seq)
one_seq = ((log_seq - min_val) / (max_val - min_val))
one_seq
# Reverse pattern of scale so breaks are focussed on lower rather than upper end of scale
one_seq_rev = one_seq %>% {. - max(.)} %>% {. * -1} %>% rev()
one_seq_rev
one_seq_rev %>% {. * n} %>% round()
one_seq_rev %>% {. * n} %>% round() %>% .[2:length(.)]
one_seq_rev %>% {. * n} %>% round() %>% .[2:length(.)] %>% c(0,1,.)
n = 68
ln=12
round_values=T
rmv_extremes=F
seq = seq(1, n, length.out = ln-2)
# Apply the logarithm to the sequence
log_seq = log(seq)
# Scale the sequence to the range [0, 1]
min_val = min(log_seq)
max_val = max(log_seq)
one_seq = ((log_seq - min_val) / (max_val - min_val))
# Reverse pattern of scale so breaks are focussed on lower rather than upper end of scale
one_seq_rev = one_seq %>% {. - max(.)} %>% {. * -1} %>% rev()
round_values
one_seq_rev %>% {. * n} %>% round() %>% .[2:length(.)] %>% c(0,1,.)
n = 68
ln=12
round_values=T
rmv_extremes=F
seq = seq(1, n, length.out = ln-1)
# Apply the logarithm to the sequence
log_seq = log(seq)
# Scale the sequence to the range [0, 1]
min_val = min(log_seq)
max_val = max(log_seq)
one_seq = ((log_seq - min_val) / (max_val - min_val))
# Reverse pattern of scale so breaks are focussed on lower rather than upper end of scale
one_seq_rev = one_seq %>% {. - max(.)} %>% {. * -1} %>% rev()
round_values
one_seq_rev %>% {. * n} %>% round() %>% .[2:length(.)] %>% c(0,1,.)
scaled_one_seq = one_seq_rev %>% {. * n} %>% round() %>% .[2:length(.)] %>% c(0,1,.)
one_seq_rev %>% {. * n} %>% .[2:length(.)] %>% c(0,.Machine$double.xmin,.)
one_seq_rev
n = 68
ln=12
round_values=T
rmv_extremes=F
n == 1
n = 68
ln=12
round_values=T
rmv_extremes=F
# Create a sequence from 1 to n.
# If `n` is specified as 1, the vector will be scaled to between 0 and 1.
if (n == 1) {
seq = seq(1, 1000, length.out = ln-1)
round_values = F
} else {
seq = seq(1, n, length.out = ln-1)
}
# Apply the logarithm to the sequence
log_seq = log(seq)
# Scale the sequence to the range [0, 1]
min_val = min(log_seq)
max_val = max(log_seq)
one_seq = ((log_seq - min_val) / (max_val - min_val))
# Reverse pattern of scale so breaks are focussed on lower rather than upper end of scale
one_seq_rev = one_seq %>% {. - max(.)} %>% {. * -1} %>% rev()
round_values
one_seq_rev %>% {. * n} %>% round() %>% .[2:length(.)] %>% c(0,1,.)
n = 1
ln=12
round_values=T
rmv_extremes=F
# Create a sequence from 1 to n.
# If `n` is specified as 1, the vector will be scaled to between 0 and 1.
if (n == 1) {
seq = seq(1, 1000, length.out = ln-1)
round_values = F
} else {
seq = seq(1, n, length.out = ln-1)
}
# Apply the logarithm to the sequence
log_seq = log(seq)
# Scale the sequence to the range [0, 1]
min_val = min(log_seq)
max_val = max(log_seq)
one_seq = ((log_seq - min_val) / (max_val - min_val))
# Reverse pattern of scale so breaks are focussed on lower rather than upper end of scale
one_seq_rev = one_seq %>% {. - max(.)} %>% {. * -1} %>% rev()
# Scale sequence to n
if (round_values) {
scaled_one_seq = one_seq_rev %>% {. * n} %>% round() %>% .[2:length(.)] %>% c(0,1,.)
} else if (n == 1) {
scaled_one_seq = one_seq_rev
} else {
scaled_one_seq = one_seq_rev %>% {. * n} %>% .[2:length(.)] %>% c(0,.Machine$double.xmin,.)
}
scaled_one_seq
n = 1
ln=12
round_values=T
rmv_extremes=F
# Create a sequence from 1 to n.
# If `n` is specified as 1, the vector will be scaled to between 0 and 1.
if (n == 1) {
seq = seq(1, 1000, length.out = ln)
round_values = F
} else {
seq = seq(1, n, length.out = ln-1)
}
# Apply the logarithm to the sequence
log_seq = log(seq)
# Scale the sequence to the range [0, 1]
min_val = min(log_seq)
max_val = max(log_seq)
one_seq = ((log_seq - min_val) / (max_val - min_val))
# Reverse pattern of scale so breaks are focussed on lower rather than upper end of scale
one_seq_rev = one_seq %>% {. - max(.)} %>% {. * -1} %>% rev()
# Scale sequence to n
if (round_values) {
scaled_one_seq = one_seq_rev %>% {. * n} %>% round() %>% .[2:length(.)] %>% c(0,1,.)
} else if (n == 1) {
scaled_one_seq = one_seq_rev
} else {
scaled_one_seq = one_seq_rev %>% {. * n} %>% .[2:length(.)] %>% c(0,.Machine$double.xmin,.)
}
scaled_one_seq
n = 68
ln=12
round_values=T
rmv_extremes=F
# Create a sequence from 1 to n.
# If `n` is specified as 1, the vector will be scaled to between 0 and 1.
if (n == 1) {
seq = seq(1, 1000, length.out = ln)
round_values = F
} else {
seq = seq(1, n, length.out = ln-1)
}
# Apply the logarithm to the sequence
log_seq = log(seq)
# Scale the sequence to the range [0, 1]
min_val = min(log_seq)
max_val = max(log_seq)
one_seq = ((log_seq - min_val) / (max_val - min_val))
# Reverse pattern of scale so breaks are focussed on lower rather than upper end of scale
one_seq_rev = one_seq %>% {. - max(.)} %>% {. * -1} %>% rev()
# Scale sequence to n
if (round_values) {
scaled_one_seq = one_seq_rev %>% {. * n} %>% round() %>% .[2:length(.)] %>% c(0,1,.)
} else if (n == 1) {
scaled_one_seq = one_seq_rev
} else {
scaled_one_seq = one_seq_rev %>% {. * n} %>% .[2:length(.)] %>% c(0,.Machine$double.xmin,.)
}
scaled_one_seq
n = 68
ln=12
round_values=F
rmv_extremes=F
# Create a sequence from 1 to n.
# If `n` is specified as 1, the vector will be scaled to between 0 and 1.
if (n == 1) {
seq = seq(1, 1000, length.out = ln)
round_values = F
} else {
seq = seq(1, n, length.out = ln-1)
}
# Apply the logarithm to the sequence
log_seq = log(seq)
# Scale the sequence to the range [0, 1]
min_val = min(log_seq)
max_val = max(log_seq)
one_seq = ((log_seq - min_val) / (max_val - min_val))
# Reverse pattern of scale so breaks are focussed on lower rather than upper end of scale
one_seq_rev = one_seq %>% {. - max(.)} %>% {. * -1} %>% rev()
# Scale sequence to n
if (round_values) {
scaled_one_seq = one_seq_rev %>% {. * n} %>% round() %>% .[2:length(.)] %>% c(0,1,.)
} else if (n == 1) {
scaled_one_seq = one_seq_rev
} else {
scaled_one_seq = one_seq_rev %>% {. * n} %>% .[2:length(.)] %>% c(0,.Machine$double.xmin,.)
}
scaled_one_seq
#'
#' @examples
#' # Create sequence of length 20, scaled between 1 and 500
#' log_seq(500,20)
#'
#' # Create sequence of length 15, scaled between 0 and 1
#' log_seq(1,12)
#'
#' @export
#' @importFrom dplyr "%>%"
log_seq = function(n,ln=15,round_values=T,rmv_extremes=F) {
# Create a sequence from 1 to n.
# If `n` is specified as 1, the vector will be scaled to between 0 and 1.
if (n == 1) {
seq = seq(1, 1000, length.out = ln)
round_values = F
} else {
seq = seq(1, n, length.out = ln-1)
}
# Apply the logarithm to the sequence
log_seq = log(seq)
# Scale the sequence to the range [0, 1]
min_val = min(log_seq)
max_val = max(log_seq)
one_seq = ((log_seq - min_val) / (max_val - min_val))
# Reverse pattern of scale so breaks are focussed on lower rather than upper end of scale
one_seq_rev = one_seq %>% {. - max(.)} %>% {. * -1} %>% rev()
# Scale sequence to n
if (round_values) {
scaled_one_seq = one_seq_rev %>% {. * n} %>% round() %>% .[2:length(.)] %>% c(0,1,.)
} else if (n == 1) {
scaled_one_seq = one_seq_rev
} else {
scaled_one_seq = one_seq_rev %>% {. * n} %>% .[2:length(.)] %>% c(0,.Machine$double.xmin,.)
}
# Option to remove zero and the maximum value (i.e. `n`) from the beginning and the end of the vector
if (rmv_extremes) {
scaled_one_seq = scaled_one_seq %>% .[2:(length(.)-1)]
}
# Return scaled sequence
return(scaled_one_seq)
}
log_seq(od_df %>% filter(`Origin County` != `Destination County`) %>% .$Migration %>% max(), 12, rmv_extremes = F)
log_seq(od_df %>% filter(`Origin County` != `Destination County`) %>% .$Migration %>% max(), 12, rmv_extremes = T)
# Create breaks to view data using a categoric scale.
# In this instance, the `hhmR` function `log_seq` has been used to create a vector of logarithmicly increasing values between 1 and
# the maximum value in the dataset not on the diagonal.
cbrks = log_seq(od_df %>% filter(`Origin County` != `Destination County`) %>% .$Migration %>% max(), 12, rmv_extremes = T)
hhm(df = od_df,
ylower = "Origin County",
xlower = "Destination County",
yupper = "Origin Region",
xupper = "Destination Region",
values = "Migration",
yttl_width = 0.22,
xttl_height = 0.4,
rm_diag = T,
cbrks = cbrks)
hhm(df = od_df,
ylower = "Origin County",
xlower = "Destination County",
yupper = "Origin Region",
xupper = "Destination Region",
values = "Migration",
yttl_width = 0.22,
xttl_height = 0.4,
rm_diag = T,
cbrks = cbrks,
cclrs = viridis_12)
# IMPORT PACKAGES
#library(hhmR)
# CREATE TOY DATA OF INTERNAL MIGRATION BETWEEN COUNTIES (LOWER LEVEL) AND REGIONS (UPPER LEVEL)
# Define names of fake counties
fake_counties = c("Greenridge","Windermoor","Bramblewood","Silverlake","Thornbury","Maplewood",
"Hawthorne","Pinehurst","Riverton","Meadowbrook","Fairhaven","Oakdale","Stonebridge",
"Brookfield","Ashford","Glenville","Sunnyvale","Westfield")
# Create region county lookup tables
rc_lkp = data.frame(region = c(rep("North",3),rep("Midlands",5),rep("South West",4),rep("South East",6)), county = fake_counties)
og_lkp = rc_lkp %>% setNames(c("Origin Region"     ,"Origin County"     ))
dn_lkp = rc_lkp %>% setNames(c("Destination Region","Destination County"))
# Create dataframe of fake migration data
set.seed(1234)
od_df = expand.grid(fake_counties,fake_counties) %>% setNames(paste(c("Origin","Destination"),"County",sep=" ")) %>% full_join(og_lkp) %>% full_join(dn_lkp) %>%
mutate(Migration = (1/rgamma(18*18, shape = 17, rate = 0.5)) %>% {. * 1000} %>% round())
od_df[od_df$`Origin County` == od_df$`Destination County`,"Migration"] = od_df[od_df$`Origin County` == od_df$`Destination County`,"Migration"] * 10
# RUN FUNCTION
# Intial heatmap
hierarchical_heatmap = hhm(df = od_df,
ylower = "Origin County",
xlower = "Destination County",
yupper = "Origin Region",
xupper = "Destination Region",
values = "Migration",
yttl_width = 0.22,
xttl_height = 0.4)
# View result
hierarchical_heatmap
# Remove diagonal from heatmap (i.e. hide static populations)
removed_diag         = hhm(df = od_df,
ylower = "Origin County",
xlower = "Destination County",
yupper = "Origin Region",
xupper = "Destination Region",
values = "Migration",
yttl_width = 0.22,
xttl_height = 0.4,
rm_diag = T)
# Vuew result
removed_diag
# Nomalise the legend
normalised_lgd       = hhm(df = od_df,
ylower = "Origin County",
xlower = "Destination County",
yupper = "Origin Region",
xupper = "Destination Region",
values = "Migration",
yttl_width = 0.22,
xttl_height = 0.4,
rm_diag = T,
norm_lgd = T)
# View result
normalised_lgd
# Manually define colour scheme for heatmap (uses viridis colour scheme)
viridis_12 = c("#440154FF","#482173FF","#433E85FF","#38598CFF","#2D708EFF","#25858EFF","#1E9B8AFF","#2BB07FFF","#51C56AFF","#85D54AFF","#C2DF23FF","#FDE725FF")
# Assign continuous colour scheme
cont_clrs            = hhm(df = od_df,
ylower = "Origin County",
xlower = "Destination County",
yupper = "Origin Region",
xupper = "Destination Region",
values = "Migration",
yttl_width = 0.22,
xttl_height = 0.4,
rm_diag = T,
norm_lgd = T,
cclrs = viridis_12)
# View result
cont_clrs
# Break legends into a specified number of bins (of equal intervals between 0 and the maximum value in `values`)
bins_15              = hhm(df = od_df,
ylower = "Origin County",
xlower = "Destination County",
yupper = "Origin Region",
xupper = "Destination Region",
values = "Migration",
yttl_width = 0.22,
xttl_height = 0.4,
rm_diag = T,
bins = 15)
# View result
bins_15
# Create breaks to view data using a categoric scale.
# In this instance, the `hhmR` function `log_seq` has been used to create a vector of logarithmicly increasing values between 1 and
# the maximum value in the dataset not on the diagonal.
cbrks = log_seq(od_df %>% filter(`Origin County` != `Destination County`) %>% .$Migration %>% max(), 12, rmv_extremes = T)
# Manually assign legend categories
legend_cats          = hhm(df = od_df,
ylower = "Origin County",
xlower = "Destination County",
yupper = "Origin Region",
xupper = "Destination Region",
values = "Migration",
yttl_width = 0.22,
xttl_height = 0.4,
rm_diag = T,
cbrks = cbrks)
# Vuew result
legend_cats
# Manually assign legend categories
cat_clrs             = hhm(df = od_df,
ylower = "Origin County",
xlower = "Destination County",
yupper = "Origin Region",
xupper = "Destination Region",
values = "Migration",
yttl_width = 0.22,
xttl_height = 0.4,
rm_diag = T,
cbrks = cbrks,
cclrs = viridis_12)
# Vuew result
cat_clrs
