# Add heatmap plots to list
plts[(i+1):(i+length(xttls))] = pl[j:(j+length(xttls)-1)]
# Adjust counters
i = i + 1 + length(xttls)
j = j +     length(xttls)
}
# Add x-axis plots
plts[[length(plts)+1]] = ps
plts[(length(plts)+1):(length(plts)+length(xttls))] = xttls
# Define final plot
plt = patchwork::wrap_plots(plts, widths = wds, heights = hts, guides = "collect")
plt
# Create breaks to view data using a categoric scale.
# These categories consist of 10 equally-spaced groups between 0 and the largest count not on the diagonal (which has been removed in this example).
cbrks = od_df %>% filter(`Origin County` != `Destination County`) %>% .$Migration %>% max() %>% seq(0, ., length.out = 10) %>% round()
# Manually assign legend categories
legend_cats          = hhm(df = od_df,
ylower = "Origin County",
xlower = "Destination County",
yupper = "Origin Region",
xupper = "Destination Region",
values = "Migration",
yttl_width = 0.22,
xttl_height = 0.4,
rm_diag = T,
cbrks = cbrks)
# Vuew result
legend_cats
hhm = function(df,ylower,yupper,xlower,xupper,values,rm_diag=F,bins=15,lgttl=NULL,cbrks=NULL,cclrs=NULL,norm_lgd=F,lgdps=3,xttl_height=0.15,yttl_width=0.15) {
# Check that supplied model inputs are compatible and won't cause errors
if (!is.null(cbrks) && !is.null(cclrs)) {
if (length(cbrks) != (length(cclrs)-1)) { stop("If both cbrks and cclrs are provideds, cbrks and cclrs must both be vectors with cclrs having a length one longer than cbrks.") }
}
if (!is.null(cbrks) && norm_lgd) {
if (min(range(cbrks)) <  0 || max(range(cbrks)) > 1) { stop("If normalising the values (norm_lgd == T), all breaks provided to cbrks must be between 0 and 1.") }
}
# Remove unwanted rows and format origin so geographies appear in alphabetical order
df = df[,c(ylower,xlower,yupper,xupper,values)]
# Define the groups to be shown along the x and y axes
# If ordering of groups already defined via factor ordering, take this as the order
# the groups should appear (top to bottom / left to right). # Otherwise, order groups alphabetically
if (!is.null(df[[xupper]] %>% levels())) {
xgrps = df[[xupper]] %>% levels()
} else {
xgrps = df[[xupper]] %>% unique() %>% sort()
}
if (!is.null(df[[yupper]] %>% levels())) {
ygrps = df[[yupper]] %>% levels()
} else {
ygrps = df[[yupper]] %>% unique() %>% sort()
}
# If user specified to remove diagonal values, set all observations where ylower and xlower are identical to zero
if (rm_diag) {
df[df[[ylower]] == df[[xlower]],values] = NA
}
# Option to normalise values between 0-1 (only works if all values are positive)
if (norm_lgd) {
# If any values are negative, return error message
if ((df[[values]] < 0) %>% sum(na.rm = T) %>% {. > 0}) {stop("norm_lgd is only designed to be used if all values used to populate the heatmap are positive.")}
# Otherwise normalise values
df[[values]] = df[[values]] / max(df[[values]], na.rm = T)
}
# Option to split legend into custom categories
if (!is.null(cbrks)) {
# If cbrks only contains whole numbers, don't manually set the decimal places
if (cbrks %>% map(~ decimalplaces(.)) %>% unlist() %>% {. > 0} %>% sum() %>% {. == 0}) {
# Define names of custom breaks
brk_nms = c(0, paste(cbrks %>% .[1:(length(.)-1)], cbrks %>% .[2: length(.)   ], sep = "-"))
} else {
# Define names of custom breaks
brk_nms = c(0, paste(cbrks %>% .[1:(length(.)-1)] %>% sprintf(fmt = paste0('%#.',lgdps,'f')),
cbrks %>% .[2: length(.)   ] %>% sprintf(fmt = paste0('%#.',lgdps,'f')), sep = "-"))
}
# Create discrete scale based on these custom breaks
df[[values]] = df[[values]] %>% findInterval(cbrks) %>%
replace(. == length(cbrks), (length(cbrks)-1)) %>%
{. + 1} %>% replace_na(1) %>%
factor(levels = 1:length(brk_nms), labels = brk_nms)
} else { # Otherwise define consistent legend scale range
lg_lims = df[[values]] %>% range(na.rm = T)
}
# Define legend title (if not defined by user)
if (is.null(lgttl) && norm_lgd) {
lgttl = "Normalised\nValues"
} else if (is.null(lgttl) && norm_lgd == F) {
lgttl = "Values"
}
# Create empty list to populate with ggplot heatmaps
pl = list()
# Define vectors capturing the number of lower categories in each upper group
xglns = df %>% group_split(!!rlang::sym(xupper)) %>% map(~ .[[xlower]] %>% unique() %>% length()) %>% unlist()
yglns = df %>% group_split(!!rlang::sym(yupper)) %>% map(~ .[[ylower]] %>% unique() %>% length()) %>% unlist()
# Counter to keep track of interations of nested for loop
i = 0
# For each y-axis group
for (ygrp in 1:length(ygrps)) {
# For each x-axis group
for (xgrp in 1:length(xgrps)) {
# Increase interature counter by 1
i = i + 1
# Filter group-level migration data to only include origin and destination regions of interest
sdf = df[df[[yupper]] == ygrps[ygrp] & df[[xupper]] == xgrps[xgrp],]
# Order lower categories alphabetically
sdf[[xlower]] = factor(sdf[[xlower]], levels = sdf[[xlower]] %>% unique() %>% sort()           )
sdf[[ylower]] = factor(sdf[[ylower]], levels = sdf[[ylower]] %>% unique() %>% sort() %>% rev() )
# Define main plot
p = ggplot(sdf, aes(.data[[xlower]], .data[[ylower]])) +
geom_tile(aes(fill = .data[[values]]), show.legend = T) +
theme(plot.margin = unit(rep(0,4), "cm"),
axis.text.x  = element_text(angle = 90, hjust = 1.0, vjust = 0.3),
axis.title.x = element_text(angle = 90, hjust = 0.5, vjust = 0.5),
axis.title.y = element_text(angle =  0, hjust = 0.5, vjust = 0.5),
axis.ticks   = element_blank()) +
labs(x = xgrps[xgrp], y = ygrps[ygrp])
# Define colour scale
if (!is.null(cbrks) && !is.null(cclrs)) {
p = p + scale_fill_manual(name = lgttl, values = cclrs                                  , drop = F, na.value = "white")
} else if (!is.null(cbrks) && is.null(cclrs)) {
p = p + scale_fill_manual(name = lgttl, values = cg("white","#08306B",(length(cbrks)+1)), drop = F, na.value = "white")
} else if (is.null(cbrks) && !is.null(cclrs)) {
p = p + scale_fill_gradientn(name = lgttl, colours = cclrs                , limits = lg_lims, na.value = "white")
} else if (is.null(cbrks) && is.null(cclrs) && norm_lgd) {
p = p + scale_fill_gradientn(name = lgttl, colours = cg("white","#08306B"), limits = c(0,1) , na.value = "white")
} else if (is.null(cbrks) && is.null(cclrs) && norm_lgd == F) {
p = p + scale_fill_gradientn(name = lgttl, colours = cg("white","#08306B"), limits = lg_lims, na.value = "white")
}
# If bottom-left plot
if (ygrp == length(ygrps) & xgrp == 1) {
# Include provincia names on both axes
p = p + theme(axis.title.x = element_blank(),
axis.title.y = element_blank())
} else if (ygrp < length(ygrps) & xgrp == 1) { # If left-hand plot
# Include provincia names on y-axis
p = p + theme(axis.title.x = element_blank(),
axis.title.y = element_blank(),
axis.text.x  = element_blank())
} else if (ygrp == length(ygrps) & xgrp > 1) { # If bottom plot
# Include provincia names on x-axis
p = p + theme(axis.title.x = element_blank(),
axis.title.y = element_blank(),
axis.text.y  = element_blank())
} else { # If plot not on left of bottom edges of multiplot
# Remove provincia names
p = p + theme(axis.title.x = element_blank(),
axis.title.y = element_blank(),
axis.text.x  = element_blank(),
axis.text.y  = element_blank())
}
# Add ggplot to plot list
pl[[i]] = p
}
}
# Define plot heights and widths (including group titles)
wds = c((sum(xglns)*yttl_width),xglns)
hts = c(yglns,(sum(yglns)*xttl_height))
# Define plot spacer
ps = plot_spacer()
# Create empty lists to be populated with plot titles
xttls = list()
yttls = list()
# Define plot titles
for (xgrp in 1:length(xgrps)) {
xttls[[xgrp]] = plt_ttl(xgrps[xgrp])
}
for (ygrp in 1:length(ygrps)) {
yttls[[ygrp]] = plt_ttl(ygrps[ygrp],axs="y")
}
# Create empty list to populate with both plot title and heatmap tiles in the correct order
plts = list()
# Define counters for subsetting plot title and heatmap lists, to ensure they are ordered correctly
i = 1
j = 1
# For each group (row), assign each plot title, then the heatmap tiles within that row to plts list
for (ygrp in 1:length(yttls)) {
# Add plot title to list
plts[[i]] = yttls[[ygrp]]
# Add heatmap plots to list
plts[(i+1):(i+length(xttls))] = pl[j:(j+length(xttls)-1)]
# Adjust counters
i = i + 1 + length(xttls)
j = j +     length(xttls)
}
# Add x-axis plots
plts[[length(plts)+1]] = ps
plts[(length(plts)+1):(length(plts)+length(xttls))] = xttls
# Define final plot
plt = patchwork::wrap_plots(plts, widths = wds, heights = hts, guides = "collect")
# Return final plot
return(plt)
}
hhm = function(df,ylower,yupper,xlower,xupper,values,rm_diag=F,lgttl=NULL,cbrks=NULL,cclrs=NULL,norm_lgd=F,lgdps=3,xttl_height=0.15,yttl_width=0.15) {
# Check that supplied model inputs are compatible and won't cause errors
if (!is.null(cbrks) && !is.null(cclrs)) {
if (length(cbrks) != (length(cclrs)-1)) { stop("If both cbrks and cclrs are provideds, cbrks and cclrs must both be vectors with cclrs having a length one longer than cbrks.") }
}
if (!is.null(cbrks) && norm_lgd) {
if (min(range(cbrks)) <  0 || max(range(cbrks)) > 1) { stop("If normalising the values (norm_lgd == T), all breaks provided to cbrks must be between 0 and 1.") }
}
# Remove unwanted rows and format origin so geographies appear in alphabetical order
df = df[,c(ylower,xlower,yupper,xupper,values)]
# Define the groups to be shown along the x and y axes
# If ordering of groups already defined via factor ordering, take this as the order
# the groups should appear (top to bottom / left to right). # Otherwise, order groups alphabetically
if (!is.null(df[[xupper]] %>% levels())) {
xgrps = df[[xupper]] %>% levels()
} else {
xgrps = df[[xupper]] %>% unique() %>% sort()
}
if (!is.null(df[[yupper]] %>% levels())) {
ygrps = df[[yupper]] %>% levels()
} else {
ygrps = df[[yupper]] %>% unique() %>% sort()
}
# If user specified to remove diagonal values, set all observations where ylower and xlower are identical to zero
if (rm_diag) {
df[df[[ylower]] == df[[xlower]],values] = NA
}
# Option to normalise values between 0-1 (only works if all values are positive)
if (norm_lgd) {
# If any values are negative, return error message
if ((df[[values]] < 0) %>% sum(na.rm = T) %>% {. > 0}) {stop("norm_lgd is only designed to be used if all values used to populate the heatmap are positive.")}
# Otherwise normalise values
df[[values]] = df[[values]] / max(df[[values]], na.rm = T)
}
# Option to split legend into custom categories
if (!is.null(cbrks)) {
# If cbrks only contains whole numbers, don't manually set the decimal places
if (cbrks %>% map(~ decimalplaces(.)) %>% unlist() %>% {. > 0} %>% sum() %>% {. == 0}) {
# Define names of custom breaks
brk_nms = c(0, paste(cbrks %>% .[1:(length(.)-1)], cbrks %>% .[2: length(.)   ], sep = "-"))
} else {
# Define names of custom breaks
brk_nms = c(0, paste(cbrks %>% .[1:(length(.)-1)] %>% sprintf(fmt = paste0('%#.',lgdps,'f')),
cbrks %>% .[2: length(.)   ] %>% sprintf(fmt = paste0('%#.',lgdps,'f')), sep = "-"))
}
# Create discrete scale based on these custom breaks
df[[values]] = df[[values]] %>% findInterval(cbrks) %>%
replace(. == length(cbrks), (length(cbrks)-1)) %>%
{. + 1} %>% replace_na(1) %>%
factor(levels = 1:length(brk_nms), labels = brk_nms)
} else { # Otherwise define consistent legend scale range
lg_lims = df[[values]] %>% range(na.rm = T)
}
# Define legend title (if not defined by user)
if (is.null(lgttl) && norm_lgd) {
lgttl = "Normalised\nValues"
} else if (is.null(lgttl) && norm_lgd == F) {
lgttl = "Values"
}
# Create empty list to populate with ggplot heatmaps
pl = list()
# Define vectors capturing the number of lower categories in each upper group
xglns = df %>% group_split(!!rlang::sym(xupper)) %>% map(~ .[[xlower]] %>% unique() %>% length()) %>% unlist()
yglns = df %>% group_split(!!rlang::sym(yupper)) %>% map(~ .[[ylower]] %>% unique() %>% length()) %>% unlist()
# Counter to keep track of interations of nested for loop
i = 0
# For each y-axis group
for (ygrp in 1:length(ygrps)) {
# For each x-axis group
for (xgrp in 1:length(xgrps)) {
# Increase interature counter by 1
i = i + 1
# Filter group-level migration data to only include origin and destination regions of interest
sdf = df[df[[yupper]] == ygrps[ygrp] & df[[xupper]] == xgrps[xgrp],]
# Order lower categories alphabetically
sdf[[xlower]] = factor(sdf[[xlower]], levels = sdf[[xlower]] %>% unique() %>% sort()           )
sdf[[ylower]] = factor(sdf[[ylower]], levels = sdf[[ylower]] %>% unique() %>% sort() %>% rev() )
# Define main plot
p = ggplot(sdf, aes(.data[[xlower]], .data[[ylower]])) +
geom_tile(aes(fill = .data[[values]]), show.legend = T) +
theme(plot.margin = unit(rep(0,4), "cm"),
axis.text.x  = element_text(angle = 90, hjust = 1.0, vjust = 0.3),
axis.title.x = element_text(angle = 90, hjust = 0.5, vjust = 0.5),
axis.title.y = element_text(angle =  0, hjust = 0.5, vjust = 0.5),
axis.ticks   = element_blank()) +
labs(x = xgrps[xgrp], y = ygrps[ygrp])
# Define colour scale
if (!is.null(cbrks) && !is.null(cclrs)) {
p = p + scale_fill_manual(name = lgttl, values = cclrs                                  , drop = F, na.value = "white")
} else if (!is.null(cbrks) && is.null(cclrs)) {
p = p + scale_fill_manual(name = lgttl, values = cg("white","#08306B",(length(cbrks)+1)), drop = F, na.value = "white")
} else if (is.null(cbrks) && !is.null(cclrs)) {
p = p + scale_fill_gradientn(name = lgttl, colours = cclrs                , limits = lg_lims, na.value = "white")
} else if (is.null(cbrks) && is.null(cclrs) && norm_lgd) {
p = p + scale_fill_gradientn(name = lgttl, colours = cg("white","#08306B"), limits = c(0,1) , na.value = "white")
} else if (is.null(cbrks) && is.null(cclrs) && norm_lgd == F) {
p = p + scale_fill_gradientn(name = lgttl, colours = cg("white","#08306B"), limits = lg_lims, na.value = "white")
}
# If bottom-left plot
if (ygrp == length(ygrps) & xgrp == 1) {
# Include provincia names on both axes
p = p + theme(axis.title.x = element_blank(),
axis.title.y = element_blank())
} else if (ygrp < length(ygrps) & xgrp == 1) { # If left-hand plot
# Include provincia names on y-axis
p = p + theme(axis.title.x = element_blank(),
axis.title.y = element_blank(),
axis.text.x  = element_blank())
} else if (ygrp == length(ygrps) & xgrp > 1) { # If bottom plot
# Include provincia names on x-axis
p = p + theme(axis.title.x = element_blank(),
axis.title.y = element_blank(),
axis.text.y  = element_blank())
} else { # If plot not on left of bottom edges of multiplot
# Remove provincia names
p = p + theme(axis.title.x = element_blank(),
axis.title.y = element_blank(),
axis.text.x  = element_blank(),
axis.text.y  = element_blank())
}
# Add ggplot to plot list
pl[[i]] = p
}
}
# Define plot heights and widths (including group titles)
wds = c((sum(xglns)*yttl_width),xglns)
hts = c(yglns,(sum(yglns)*xttl_height))
# Define plot spacer
ps = plot_spacer()
# Create empty lists to be populated with plot titles
xttls = list()
yttls = list()
# Define plot titles
for (xgrp in 1:length(xgrps)) {
xttls[[xgrp]] = plt_ttl(xgrps[xgrp])
}
for (ygrp in 1:length(ygrps)) {
yttls[[ygrp]] = plt_ttl(ygrps[ygrp],axs="y")
}
# Create empty list to populate with both plot title and heatmap tiles in the correct order
plts = list()
# Define counters for subsetting plot title and heatmap lists, to ensure they are ordered correctly
i = 1
j = 1
# For each group (row), assign each plot title, then the heatmap tiles within that row to plts list
for (ygrp in 1:length(yttls)) {
# Add plot title to list
plts[[i]] = yttls[[ygrp]]
# Add heatmap plots to list
plts[(i+1):(i+length(xttls))] = pl[j:(j+length(xttls)-1)]
# Adjust counters
i = i + 1 + length(xttls)
j = j +     length(xttls)
}
# Add x-axis plots
plts[[length(plts)+1]] = ps
plts[(length(plts)+1):(length(plts)+length(xttls))] = xttls
# Define final plot
plt = patchwork::wrap_plots(plts, widths = wds, heights = hts, guides = "collect")
# Return final plot
return(plt)
}
# Manually assign legend categories
legend_cats          = hhm(df = od_df,
ylower = "Origin County",
xlower = "Destination County",
yupper = "Origin Region",
xupper = "Destination Region",
values = "Migration",
yttl_width = 0.22,
xttl_height = 0.4,
rm_diag = T,
cbrks = cbrks)
# Vuew result
legend_cats
cbrks
# Import package
#library(hhmR)
library(viridis)
viridis(10)
# Manually define colour scheme for heatmap
viridis_10 = c("#440154FF","#482878FF","#3E4A89FF","#31688EFF","#26828EFF","#1F9E89FF","#35B779FF","#6DCD59FF","#B4DE2CFF","#FDE725FF")
df = od_df
ylower = "Origin County"
xlower = "Destination County"
yupper = "Origin Region"
xupper = "Destination Region"
values = "Migration"
rm_diag = T
lgttl=NULL
cbrks=od_df %>% filter(`Origin County` != `Destination County`) %>% .$Migration %>% max() %>% seq(0, ., length.out = 10) %>% round()
cclrs=viridis_10
norm_lgd=F
lgdps=3
yttl_width = 0.22
xttl_height = 0.4
df = od_df
ylower = "Origin County"
xlower = "Destination County"
yupper = "Origin Region"
xupper = "Destination Region"
values = "Migration"
rm_diag = T
lgttl=NULL
cbrks=od_df %>% filter(`Origin County` != `Destination County`) %>% .$Migration %>% max() %>% seq(0, ., length.out = 10) %>% round()
cclrs=viridis_10
norm_lgd=F
lgdps=3
yttl_width = 0.22
xttl_height = 0.4
df = od_df
ylower = "Origin County"
xlower = "Destination County"
yupper = "Origin Region"
xupper = "Destination Region"
values = "Migration"
rm_diag = T
lgttl=NULL
cbrks=od_df %>% filter(`Origin County` != `Destination County`) %>% .$Migration %>% max() %>% seq(0, ., length.out = 10) %>% round()
cclrs=viridis_10
norm_lgd=F
lgdps=3
yttl_width = 0.22
xttl_height = 0.4
length(cbrks)
length(cclrs))
length(cclrs)
length(cbrks) != length(cclrs)
# Remove unwanted rows and format origin so geographies appear in alphabetical order
df = df[,c(ylower,xlower,yupper,xupper,values)]
# Define the groups to be shown along the x and y axes
# If ordering of groups already defined via factor ordering, take this as the order
# the groups should appear (top to bottom / left to right). # Otherwise, order groups alphabetically
if (!is.null(df[[xupper]] %>% levels())) {
xgrps = df[[xupper]] %>% levels()
} else {
xgrps = df[[xupper]] %>% unique() %>% sort()
}
if (!is.null(df[[yupper]] %>% levels())) {
ygrps = df[[yupper]] %>% levels()
} else {
ygrps = df[[yupper]] %>% unique() %>% sort()
}
df = od_df
ylower = "Origin County"
xlower = "Destination County"
yupper = "Origin Region"
xupper = "Destination Region"
values = "Migration"
rm_diag = T
lgttl=NULL
cbrks=od_df %>% filter(`Origin County` != `Destination County`) %>% .$Migration %>% max() %>% seq(0, ., length.out = 10) %>% round()
cclrs=viridis(11)
norm_lgd=F
lgdps=3
yttl_width = 0.22
xttl_height = 0.4
# Check that supplied model inputs are compatible and won't cause errors
if (!is.null(cbrks) && !is.null(cclrs)) {
if (length(cbrks) != (length(cclrs)-1)) { stop("If both cbrks and cclrs are provideds, cbrks and cclrs must both be vectors with cclrs having a length one longer than cbrks.") }
}
if (!is.null(cbrks) && norm_lgd) {
if (min(range(cbrks)) <  0 || max(range(cbrks)) > 1) { stop("If normalising the values (norm_lgd == T), all breaks provided to cbrks must be between 0 and 1.") }
}
# Remove unwanted rows and format origin so geographies appear in alphabetical order
df = df[,c(ylower,xlower,yupper,xupper,values)]
# Define the groups to be shown along the x and y axes
# If ordering of groups already defined via factor ordering, take this as the order
# the groups should appear (top to bottom / left to right). # Otherwise, order groups alphabetically
if (!is.null(df[[xupper]] %>% levels())) {
xgrps = df[[xupper]] %>% levels()
} else {
xgrps = df[[xupper]] %>% unique() %>% sort()
}
if (!is.null(df[[yupper]] %>% levels())) {
ygrps = df[[yupper]] %>% levels()
} else {
ygrps = df[[yupper]] %>% unique() %>% sort()
}
# If user specified to remove diagonal values, set all observations where ylower and xlower are identical to zero
if (rm_diag) {
df[df[[ylower]] == df[[xlower]],values] = NA
}
# Option to normalise values between 0-1 (only works if all values are positive)
if (norm_lgd) {
# If any values are negative, return error message
if ((df[[values]] < 0) %>% sum(na.rm = T) %>% {. > 0}) {stop("norm_lgd is only designed to be used if all values used to populate the heatmap are positive.")}
# Otherwise normalise values
df[[values]] = df[[values]] / max(df[[values]], na.rm = T)
}
# Option to split legend into custom categories
if (!is.null(cbrks)) {
# If cbrks only contains whole numbers, don't manually set the decimal places
if (cbrks %>% map(~ decimalplaces(.)) %>% unlist() %>% {. > 0} %>% sum() %>% {. == 0}) {
# Define names of custom breaks
brk_nms = c(0, paste(cbrks %>% .[1:(length(.)-1)], cbrks %>% .[2: length(.)   ], sep = "-"))
} else {
# Define names of custom breaks
brk_nms = c(0, paste(cbrks %>% .[1:(length(.)-1)] %>% sprintf(fmt = paste0('%#.',lgdps,'f')),
cbrks %>% .[2: length(.)   ] %>% sprintf(fmt = paste0('%#.',lgdps,'f')), sep = "-"))
}
# Create discrete scale based on these custom breaks
df[[values]] = df[[values]] %>% findInterval(cbrks) %>%
replace(. == length(cbrks), (length(cbrks)-1)) %>%
{. + 1} %>% replace_na(1) %>%
factor(levels = 1:length(brk_nms), labels = brk_nms)
} else { # Otherwise define consistent legend scale range
lg_lims = df[[values]] %>% range(na.rm = T)
}
# Define legend title (if not defined by user)
if (is.null(lgttl) && norm_lgd) {
lgttl = "Normalised\nValues"
} else if (is.null(lgttl) && norm_lgd == F) {
lgttl = "Values"
}
# Create empty list to populate with ggplot heatmaps
pl = list()
# Define vectors capturing the number of lower categories in each upper group
xglns = df %>% group_split(!!rlang::sym(xupper)) %>% map(~ .[[xlower]] %>% unique() %>% length()) %>% unlist()
yglns = df %>% group_split(!!rlang::sym(yupper)) %>% map(~ .[[ylower]] %>% unique() %>% length()) %>% unlist()
# Counter to keep track of interations of nested for loop
i = 0
