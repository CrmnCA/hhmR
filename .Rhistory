} else {
xgrps = df[[xupper]] %>% unique() %>% sort()
}
if (!is.null(df[[yupper]] %>% levels())) {
ygrps = df[[yupper]] %>% levels()
} else {
ygrps = df[[yupper]] %>% unique() %>% sort()
}
# If user specified to remove diagonal values, set all observations where ylower and xlower are identical to zero
if (rm_diag) {
df[df[[ylower]] == df[[xlower]],values] = NA
}
# Option to normalise values between 0-1 (only works if all values are positive)
if (norm_brks) {
# If any values are negative, return error message
if ((df[[values]] < 0) %>% sum() %>% {. > 0}) {stop("norm_brks is only designed to be used if all values used to populate the heatmap are positive.")}
# Otherwise normalise values
df[[values]] = df[[values]] / max(df[[values]])
}
# Option to split legend into custom categories
if (!is.null(cbrks)) {
# Define names of custom breaks
brk_nms = c(0, paste(cbrks %>% .[1:(length(.)-1)] %>% sprintf(fmt = paste0('%#.',lgdps,'f')),
cbrks %>% .[2: length(.)   ] %>% sprintf(fmt = paste0('%#.',lgdps,'f')), sep = "-"))
# Create discrete scale based on these custom breaks
df[[values]] = df[[values]] %>% findInterval(cbrks) %>% ifelse(df[[paste0(var,"_scld")]] == 0, 0, .) %>%
replace(. == length(cbrks), (length(cbrks)-1)) %>% {. + 1} %>% factor(levels = 1:bns, labels = brk_nms)
} else { # Otherwise define consistent legend scale range
lg_lims = df[[values]] %>% range()
}
# Define legend title (if not defined by user)
if (is.null(lgttl) && norm_brks) {
lgttl = "Normalised\nValues"
} else if (is.null(lgttl) && norm_brks == F) {
lgttl = "Values"
}
# Create empty list to populate with ggplot heatmaps
pl = list()
# Define vectors capturing the number of lower categories in each upper group
xglns = df %>% group_split(!!rlang::sym(xupper)) %>% map(~ .[[xlower]] %>% unique() %>% length()) %>% unlist()
yglns = df %>% group_split(!!rlang::sym(yupper)) %>% map(~ .[[ylower]] %>% unique() %>% length()) %>% unlist()
# Counter to keep track of interations of nested for loop
i = 0
# For each y-axis group
for (ygrp in 1:length(ygrps)) {
# For each x-axis group
for (xgrp in 1:length(xgrps)) {
# Increase interature counter by 1
i = i + 1
# Filter group-level migration data to only include origin and destination regions of interest
sdf = df[df[[yupper]] == ygrps[ygrp] & df[[xupper]] == xgrps[xgrp],]
# Order lower categories alphabetically
sdf[[xlower]] = factor(sdf[[xlower]], levels = sdf[[xlower]] %>% unique() %>% sort()           )
sdf[[ylower]] = factor(sdf[[ylower]], levels = sdf[[ylower]] %>% unique() %>% sort() %>% rev() )
# Define main plot
p = ggplot(sdf, aes(.data[[xlower]], .data[[ylower]])) +
geom_tile(aes(fill = .data[[values]]), show.legend = T) +
theme(plot.margin = unit(rep(0,4), "cm"),
axis.text.x  = element_text(angle = 90, hjust = 1.0, vjust = 0.3),
axis.title.x = element_text(angle = 90, hjust = 0.5, vjust = 0.5),
axis.title.y = element_text(angle =  0, hjust = 0.5, vjust = 0.5),
axis.ticks   = element_blank()) +
labs(x = xgrps[xgrp], y = ygrps[ygrp])
# Define colour scale
if (!is.null(cbrks) && !is.null(cclrs)) {
p = p + scale_fill_manual(name = lgttl, values = cclrs                                  , drop = F, na.value = "white")
} else if (!is.null(cbrks) && is.null(cclrs)) {
p = p + scale_fill_manual(name = lgttl, values = cg("white","#08306B",(length(cbrks)+1)), drop = F, na.value = "white")
} else if (is.null(cbrks) && !is.null(cclrs)) {
p = p + scale_fill_gradientn(name = lgttl, colours = cclrs                , limits = lg_lims, na.value = "white")
} else if (is.null(cbrks) && is.null(cclrs)) {
p = p + scale_fill_gradientn(name = lgttl, colours = cg("white","#08306B"), limits = lg_lims, na.value = "white")
}
# If bottom-left plot
if (ygrp == length(ygrps) & xgrp == 1) {
# Include provincia names on both axes
p = p + theme(axis.title.x = element_blank(),
axis.title.y = element_blank())
} else if (ygrp < length(ygrps) & xgrp == 1) { # If left-hand plot
# Include provincia names on y-axis
p = p + theme(axis.title.x = element_blank(),
axis.title.y = element_blank(),
axis.text.x  = element_blank())
} else if (ygrp == length(ygrps) & xgrp > 1) { # If bottom plot
# Include provincia names on x-axis
p = p + theme(axis.title.x = element_blank(),
axis.title.y = element_blank(),
axis.text.y  = element_blank())
} else { # If plot not on left of bottom edges of multiplot
# Remove provincia names
p = p + theme(axis.title.x = element_blank(),
axis.title.y = element_blank(),
axis.text.x  = element_blank(),
axis.text.y  = element_blank())
}
# Add ggplot to plot list
pl[[i]] = p
}
}
# Define plot heights and widths (including group titles)
wds = c((sum(xglns)*xttl_height),xglns)
hts = c(yglns,(sum(yglns)*yttl_width ))
# Define plot spacer
ps = plot_spacer()
# Create empty lists to be populated with plot titles
xttls = list()
yttls = list()
# Define plot titles
for (xgrp in 1:length(xgrps)) {
xttls[[xgrp]] = plt_ttl(xgrps[xgrp])
}
for (ygrp in 1:length(ygrps)) {
yttls[[ygrp]] = plt_ttl(ygrps[ygrp],axs="y")
}
# Create empty list to populate with both plot title and heatmap tiles in the correct order
plts = list()
# Define counters for subsetting plot title and heatmap lists, to ensure they are ordered correctly
i = 1
j = 1
# For each group (row), assign each plot title, then the heatmap tiles within that row to plts list
for (ygrp in 1:length(yttls)) {
# Add plot title to list
plts[[i]] = yttls[[ygrp]]
# Add heatmap plots to list
plts[(i+1):(i+length(xttls))] = pl[j:(j+length(xttls)-1)]
# Adjust counters
i = i + 1 + length(xttls)
j = j +     length(xttls)
}
# Add x-axis plots
plts[[length(plts)+1]] = ps
plts[(length(plts)+1):(length(plts)+length(xttls))] = xttls
# Define final plot
plt = patchwork::wrap_plots(plts, widths = wds, heights = hts, guides = "collect")
# Return final plot
return(plt)
}
# Import package
#library(hhmR)
# CREATE TOY DATA OF INTERNAL MIGRATION BETWEEN COUNTIES (LOWER LEVEL) AND REGIONS (UPPER LEVEL)
# Define names of fake counties
fake_counties = c("Greenridge","Windermoor","Bramblewood","Silverlake","Thornbury","Maplewood",
"Hawthorne","Pinehurst","Riverton","Meadowbrook","Fairhaven","Oakdale","Stonebridge",
"Brookfield","Ashford","Glenville","Sunnyvale","Westfield")
# Create region county lookup tables
rc_lkp = data.frame(region = c(rep("North",3),rep("Midlands",5),rep("South West",4),rep("South East",6)), county = fake_counties)
og_lkp = rc_lkp %>% setNames(c("Origin Region"     ,"Origin County"     ))
dn_lkp = rc_lkp %>% setNames(c("Destination Region","Destination County"))
# Create dataframe of fake migration data
set.seed(1234)
od_df = expand.grid(fake_counties,fake_counties) %>% setNames(paste(c("Origin","Destination"),"County",sep=" ")) %>% full_join(og_lkp) %>% full_join(dn_lkp) %>%
mutate(Migration = (1/rgamma(18*18, shape = 17, rate = 0.5)) %>% {. * 1000} %>% round())
od_df[od_df$`Origin County` == od_df$`Destination County`,"Migration"] = od_df[od_df$`Origin County` == od_df$`Destination County`,"Migration"] * 10
# RUN FUNCTION
hierarchical_heatmap = hhm(df = od_df, ylower = "Origin County", xlower = "Destination County", yupper = "Origin Region", xupper = "Destination Region", values = "Migration")
hierarchical_heatmap
# RUN FUNCTION
hierarchical_heatmap = hhm(df = od_df, ylower = "Origin County", xlower = "Destination County", yupper = "Origin Region", xupper = "Destination Region", values = "Migration",yttl_width = 0.3)
hierarchical_heatmap
yttl_width=0.3
c(yglns,(sum(yglns)*yttl_width))
yttl_width=0.15
c(yglns,(sum(yglns)*yttl_width))
View(hhm)
View(hhm)
# RUN FUNCTION
hierarchical_heatmap = hhm(df = od_df, ylower = "Origin County", xlower = "Destination County", yupper = "Origin Region", xupper = "Destination Region", values = "Migration", yttl_width = 0.5)
# VIEW HEATMAP
hierarchical_heatmap
df = od_df
ylower = "Origin County"
xlower = "Destination County"
yupper = "Origin Region"
xupper = "Destination Region"
values = "Migration"
rm_diag = F
bins = 15
lgttl=NULL
cbrks=NULL
cclrs=NULL
norm_brks=F
lgdps=3
xttl_height=0.15
yttl_width=0.5
# Check that supplied model inputs are compatible and won't cause errors
if (!is.null(cbrks) && !is.null(cclrs)) {
if (length(cbrks) != (length(cclrs)-1)) { stop("If both cbrks and cclrs are provideds, cbrks and cclrs must both be vectors with cclrs having a length one longer than cbrks.") }
}
if (!is.null(cbrks) && norm_brks) {
if (min(range(cbrks)) <  0 || max(range(cbrks)) > 1) { stop("If normalising the values (norm_brks == T), all breaks provided to cbrks must be between 0 and 1.") }
}
# Remove unwanted rows and format origin so geographies appear in alphabetical order
df = df[,c(ylower,xlower,yupper,xupper,values)]
# Define the groups to be shown along the x and y axes
# If ordering of groups already defined via factor ordering, take this as the order
# the groups should appear (top to bottom / left to right). # Otherwise, order groups alphabetically
if (!is.null(df[[xupper]] %>% levels())) {
xgrps = df[[xupper]] %>% levels()
} else {
xgrps = df[[xupper]] %>% unique() %>% sort()
}
if (!is.null(df[[yupper]] %>% levels())) {
ygrps = df[[yupper]] %>% levels()
} else {
ygrps = df[[yupper]] %>% unique() %>% sort()
}
# If user specified to remove diagonal values, set all observations where ylower and xlower are identical to zero
if (rm_diag) {
df[df[[ylower]] == df[[xlower]],values] = NA
}
# Option to normalise values between 0-1 (only works if all values are positive)
if (norm_brks) {
# If any values are negative, return error message
if ((df[[values]] < 0) %>% sum() %>% {. > 0}) {stop("norm_brks is only designed to be used if all values used to populate the heatmap are positive.")}
# Otherwise normalise values
df[[values]] = df[[values]] / max(df[[values]])
}
# Option to split legend into custom categories
if (!is.null(cbrks)) {
# Define names of custom breaks
brk_nms = c(0, paste(cbrks %>% .[1:(length(.)-1)] %>% sprintf(fmt = paste0('%#.',lgdps,'f')),
cbrks %>% .[2: length(.)   ] %>% sprintf(fmt = paste0('%#.',lgdps,'f')), sep = "-"))
# Create discrete scale based on these custom breaks
df[[values]] = df[[values]] %>% findInterval(cbrks) %>% ifelse(df[[paste0(var,"_scld")]] == 0, 0, .) %>%
replace(. == length(cbrks), (length(cbrks)-1)) %>% {. + 1} %>% factor(levels = 1:bns, labels = brk_nms)
} else { # Otherwise define consistent legend scale range
lg_lims = df[[values]] %>% range()
}
# Define legend title (if not defined by user)
if (is.null(lgttl) && norm_brks) {
lgttl = "Normalised\nValues"
} else if (is.null(lgttl) && norm_brks == F) {
lgttl = "Values"
}
# Create empty list to populate with ggplot heatmaps
pl = list()
# Define vectors capturing the number of lower categories in each upper group
xglns = df %>% group_split(!!rlang::sym(xupper)) %>% map(~ .[[xlower]] %>% unique() %>% length()) %>% unlist()
yglns = df %>% group_split(!!rlang::sym(yupper)) %>% map(~ .[[ylower]] %>% unique() %>% length()) %>% unlist()
# Counter to keep track of interations of nested for loop
i = 0
# For each y-axis group
for (ygrp in 1:length(ygrps)) {
# For each x-axis group
for (xgrp in 1:length(xgrps)) {
# Increase interature counter by 1
i = i + 1
# Filter group-level migration data to only include origin and destination regions of interest
sdf = df[df[[yupper]] == ygrps[ygrp] & df[[xupper]] == xgrps[xgrp],]
# Order lower categories alphabetically
sdf[[xlower]] = factor(sdf[[xlower]], levels = sdf[[xlower]] %>% unique() %>% sort()           )
sdf[[ylower]] = factor(sdf[[ylower]], levels = sdf[[ylower]] %>% unique() %>% sort() %>% rev() )
# Define main plot
p = ggplot(sdf, aes(.data[[xlower]], .data[[ylower]])) +
geom_tile(aes(fill = .data[[values]]), show.legend = T) +
theme(plot.margin = unit(rep(0,4), "cm"),
axis.text.x  = element_text(angle = 90, hjust = 1.0, vjust = 0.3),
axis.title.x = element_text(angle = 90, hjust = 0.5, vjust = 0.5),
axis.title.y = element_text(angle =  0, hjust = 0.5, vjust = 0.5),
axis.ticks   = element_blank()) +
labs(x = xgrps[xgrp], y = ygrps[ygrp])
# Define colour scale
if (!is.null(cbrks) && !is.null(cclrs)) {
p = p + scale_fill_manual(name = lgttl, values = cclrs                                  , drop = F, na.value = "white")
} else if (!is.null(cbrks) && is.null(cclrs)) {
p = p + scale_fill_manual(name = lgttl, values = cg("white","#08306B",(length(cbrks)+1)), drop = F, na.value = "white")
} else if (is.null(cbrks) && !is.null(cclrs)) {
p = p + scale_fill_gradientn(name = lgttl, colours = cclrs                , limits = lg_lims, na.value = "white")
} else if (is.null(cbrks) && is.null(cclrs)) {
p = p + scale_fill_gradientn(name = lgttl, colours = cg("white","#08306B"), limits = lg_lims, na.value = "white")
}
# If bottom-left plot
if (ygrp == length(ygrps) & xgrp == 1) {
# Include provincia names on both axes
p = p + theme(axis.title.x = element_blank(),
axis.title.y = element_blank())
} else if (ygrp < length(ygrps) & xgrp == 1) { # If left-hand plot
# Include provincia names on y-axis
p = p + theme(axis.title.x = element_blank(),
axis.title.y = element_blank(),
axis.text.x  = element_blank())
} else if (ygrp == length(ygrps) & xgrp > 1) { # If bottom plot
# Include provincia names on x-axis
p = p + theme(axis.title.x = element_blank(),
axis.title.y = element_blank(),
axis.text.y  = element_blank())
} else { # If plot not on left of bottom edges of multiplot
# Remove provincia names
p = p + theme(axis.title.x = element_blank(),
axis.title.y = element_blank(),
axis.text.x  = element_blank(),
axis.text.y  = element_blank())
}
# Add ggplot to plot list
pl[[i]] = p
}
}
# Define plot heights and widths (including group titles)
wds = c((sum(xglns)*xttl_height),xglns)
hts = c(yglns,(sum(yglns)*yttl_width))
# Define plot spacer
ps = plot_spacer()
# Create empty lists to be populated with plot titles
xttls = list()
yttls = list()
# Define plot heights and widths (including group titles)
wds = c((sum(xglns)*yttl_width),xglns)
hts = c(yglns,(sum(yglns)*xttl_height))
wds
sum(xglns)
sum(xglns)*yttl_width
xglns
# Define plot heights and widths (including group titles)
wds = c((sum(xglns)*yttl_width),xglns)
hts = c(yglns,(sum(yglns)*xttl_height))
# Define plot spacer
ps = plot_spacer()
# Create empty lists to be populated with plot titles
xttls = list()
yttls = list()
# Define plot titles
for (xgrp in 1:length(xgrps)) {
xttls[[xgrp]] = plt_ttl(xgrps[xgrp])
}
for (ygrp in 1:length(ygrps)) {
yttls[[ygrp]] = plt_ttl(ygrps[ygrp],axs="y")
}
# Create empty list to populate with both plot title and heatmap tiles in the correct order
plts = list()
# Define counters for subsetting plot title and heatmap lists, to ensure they are ordered correctly
i = 1
j = 1
# For each group (row), assign each plot title, then the heatmap tiles within that row to plts list
for (ygrp in 1:length(yttls)) {
# Add plot title to list
plts[[i]] = yttls[[ygrp]]
# Add heatmap plots to list
plts[(i+1):(i+length(xttls))] = pl[j:(j+length(xttls)-1)]
# Adjust counters
i = i + 1 + length(xttls)
j = j +     length(xttls)
}
# Add x-axis plots
plts[[length(plts)+1]] = ps
plts[(length(plts)+1):(length(plts)+length(xttls))] = xttls
# Define final plot
plt = patchwork::wrap_plots(plts, widths = wds, heights = hts, guides = "collect")
plt
df = od_df
ylower = "Origin County"
xlower = "Destination County"
yupper = "Origin Region"
xupper = "Destination Region"
values = "Migration"
rm_diag = F
bins = 15
lgttl=NULL
cbrks=NULL
cclrs=NULL
norm_brks=F
lgdps=3
xttl_height=0.15
yttl_width=0.15
# Check that supplied model inputs are compatible and won't cause errors
if (!is.null(cbrks) && !is.null(cclrs)) {
if (length(cbrks) != (length(cclrs)-1)) { stop("If both cbrks and cclrs are provideds, cbrks and cclrs must both be vectors with cclrs having a length one longer than cbrks.") }
}
if (!is.null(cbrks) && norm_brks) {
if (min(range(cbrks)) <  0 || max(range(cbrks)) > 1) { stop("If normalising the values (norm_brks == T), all breaks provided to cbrks must be between 0 and 1.") }
}
# Remove unwanted rows and format origin so geographies appear in alphabetical order
df = df[,c(ylower,xlower,yupper,xupper,values)]
# Define the groups to be shown along the x and y axes
# If ordering of groups already defined via factor ordering, take this as the order
# the groups should appear (top to bottom / left to right). # Otherwise, order groups alphabetically
if (!is.null(df[[xupper]] %>% levels())) {
xgrps = df[[xupper]] %>% levels()
} else {
xgrps = df[[xupper]] %>% unique() %>% sort()
}
if (!is.null(df[[yupper]] %>% levels())) {
ygrps = df[[yupper]] %>% levels()
} else {
ygrps = df[[yupper]] %>% unique() %>% sort()
}
# If user specified to remove diagonal values, set all observations where ylower and xlower are identical to zero
if (rm_diag) {
df[df[[ylower]] == df[[xlower]],values] = NA
}
# Option to normalise values between 0-1 (only works if all values are positive)
if (norm_brks) {
# If any values are negative, return error message
if ((df[[values]] < 0) %>% sum() %>% {. > 0}) {stop("norm_brks is only designed to be used if all values used to populate the heatmap are positive.")}
# Otherwise normalise values
df[[values]] = df[[values]] / max(df[[values]])
}
# Option to split legend into custom categories
if (!is.null(cbrks)) {
# Define names of custom breaks
brk_nms = c(0, paste(cbrks %>% .[1:(length(.)-1)] %>% sprintf(fmt = paste0('%#.',lgdps,'f')),
cbrks %>% .[2: length(.)   ] %>% sprintf(fmt = paste0('%#.',lgdps,'f')), sep = "-"))
# Create discrete scale based on these custom breaks
df[[values]] = df[[values]] %>% findInterval(cbrks) %>% ifelse(df[[paste0(var,"_scld")]] == 0, 0, .) %>%
replace(. == length(cbrks), (length(cbrks)-1)) %>% {. + 1} %>% factor(levels = 1:bns, labels = brk_nms)
} else { # Otherwise define consistent legend scale range
lg_lims = df[[values]] %>% range()
}
# Define legend title (if not defined by user)
if (is.null(lgttl) && norm_brks) {
lgttl = "Normalised\nValues"
} else if (is.null(lgttl) && norm_brks == F) {
lgttl = "Values"
}
# Create empty list to populate with ggplot heatmaps
pl = list()
# Define vectors capturing the number of lower categories in each upper group
xglns = df %>% group_split(!!rlang::sym(xupper)) %>% map(~ .[[xlower]] %>% unique() %>% length()) %>% unlist()
yglns = df %>% group_split(!!rlang::sym(yupper)) %>% map(~ .[[ylower]] %>% unique() %>% length()) %>% unlist()
# Counter to keep track of interations of nested for loop
i = 0
# For each y-axis group
for (ygrp in 1:length(ygrps)) {
# For each x-axis group
for (xgrp in 1:length(xgrps)) {
# Increase interature counter by 1
i = i + 1
# Filter group-level migration data to only include origin and destination regions of interest
sdf = df[df[[yupper]] == ygrps[ygrp] & df[[xupper]] == xgrps[xgrp],]
# Order lower categories alphabetically
sdf[[xlower]] = factor(sdf[[xlower]], levels = sdf[[xlower]] %>% unique() %>% sort()           )
sdf[[ylower]] = factor(sdf[[ylower]], levels = sdf[[ylower]] %>% unique() %>% sort() %>% rev() )
# Define main plot
p = ggplot(sdf, aes(.data[[xlower]], .data[[ylower]])) +
geom_tile(aes(fill = .data[[values]]), show.legend = T) +
theme(plot.margin = unit(rep(0,4), "cm"),
axis.text.x  = element_text(angle = 90, hjust = 1.0, vjust = 0.3),
axis.title.x = element_text(angle = 90, hjust = 0.5, vjust = 0.5),
axis.title.y = element_text(angle =  0, hjust = 0.5, vjust = 0.5),
axis.ticks   = element_blank()) +
labs(x = xgrps[xgrp], y = ygrps[ygrp])
# Define colour scale
if (!is.null(cbrks) && !is.null(cclrs)) {
p = p + scale_fill_manual(name = lgttl, values = cclrs                                  , drop = F, na.value = "white")
} else if (!is.null(cbrks) && is.null(cclrs)) {
p = p + scale_fill_manual(name = lgttl, values = cg("white","#08306B",(length(cbrks)+1)), drop = F, na.value = "white")
} else if (is.null(cbrks) && !is.null(cclrs)) {
p = p + scale_fill_gradientn(name = lgttl, colours = cclrs                , limits = lg_lims, na.value = "white")
} else if (is.null(cbrks) && is.null(cclrs)) {
p = p + scale_fill_gradientn(name = lgttl, colours = cg("white","#08306B"), limits = lg_lims, na.value = "white")
}
# If bottom-left plot
if (ygrp == length(ygrps) & xgrp == 1) {
# Include provincia names on both axes
p = p + theme(axis.title.x = element_blank(),
axis.title.y = element_blank())
} else if (ygrp < length(ygrps) & xgrp == 1) { # If left-hand plot
# Include provincia names on y-axis
p = p + theme(axis.title.x = element_blank(),
axis.title.y = element_blank(),
axis.text.x  = element_blank())
} else if (ygrp == length(ygrps) & xgrp > 1) { # If bottom plot
# Include provincia names on x-axis
p = p + theme(axis.title.x = element_blank(),
axis.title.y = element_blank(),
axis.text.y  = element_blank())
} else { # If plot not on left of bottom edges of multiplot
# Remove provincia names
p = p + theme(axis.title.x = element_blank(),
axis.title.y = element_blank(),
axis.text.x  = element_blank(),
axis.text.y  = element_blank())
}
# Add ggplot to plot list
pl[[i]] = p
}
}
# Define plot heights and widths (including group titles)
wds = c((sum(xglns)*yttl_width),xglns)
hts = c(yglns,(sum(yglns)*xttl_height))
# Define plot spacer
ps = plot_spacer()
# Create empty lists to be populated with plot titles
xttls = list()
yttls = list()
# Define plot titles
for (xgrp in 1:length(xgrps)) {
xttls[[xgrp]] = plt_ttl(xgrps[xgrp])
}
for (ygrp in 1:length(ygrps)) {
yttls[[ygrp]] = plt_ttl(ygrps[ygrp],axs="y")
}
# Create empty list to populate with both plot title and heatmap tiles in the correct order
plts = list()
# Define counters for subsetting plot title and heatmap lists, to ensure they are ordered correctly
i = 1
j = 1
# For each group (row), assign each plot title, then the heatmap tiles within that row to plts list
for (ygrp in 1:length(yttls)) {
# Add plot title to list
plts[[i]] = yttls[[ygrp]]
# Add heatmap plots to list
plts[(i+1):(i+length(xttls))] = pl[j:(j+length(xttls)-1)]
# Adjust counters
i = i + 1 + length(xttls)
j = j +     length(xttls)
}
# Add x-axis plots
plts[[length(plts)+1]] = ps
plts[(length(plts)+1):(length(plts)+length(xttls))] = xttls
# Define final plot
plt = patchwork::wrap_plots(plts, widths = wds, heights = hts, guides = "collect")
plt
